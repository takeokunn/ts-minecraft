# DDD改善実行計画

## 背景
- `src/domain` 配下の集約やサービスに Three.js, DOM API, 永続化技術が入り込み、ドメインと技術基盤の結合度が高い。
- `src/app` と `src/infrastructure` の責務が重複し、ユースケース実装がプレゼンテーション層や Live 実装に散在している。
- テスト・型チェックの対象が限定的で、レイヤ横断の退行を把握しづらい。

## 目的
- ドメイン層をユビキタス言語・ビジネスルール・ポート定義のみに絞り、技術的詳細を排除する。
- アプリケーション層でユースケースを明文化し、プレゼンテーション層からドメインへの直接依存を解消する。
- インフラ層へ技術的詳細を集約し、依存関係の一方向性を保証できる構成へ再設計する。

### 成功指標
- ドメイン層の `import` 先が自層もしくは純粋な型定義のみとなり、UI／永続化／外部ライブラリを参照しない。
- 主要ユースケース（起動、停止、シーン切替、入力処理等）がアプリケーション層のサービスとして実装される。
- ポートとアダプタの組合せに対する契約テストが整備され、CI でレイヤ侵食が検知できる。
- tsconfig とテストスイートが `src` 全体を対象とし、フェーズ完了後のテストで回帰がゼロである。

## 対象スコープ
- `src/domain`, `src/app`, `src/infrastructure`, `src/presentation` の構造見直し。
- Three.js, ブラウザ API, IndexedDB 等の技術依存箇所の抽象化。
- tsconfig, テスト設定、依存注入のエントリポイント（例: `src/main.ts`）の整理。

## 推奨ディレクトリ構造
```text
src/
  domain/
    <bounded-context>/
      aggregates/
      entities/
      value-objects/
      services/
      ports/
      events/
      policies/
    shared/
  application/
    usecases/
      commands/
      queries/
    facades/
    dto/
    mappers/
  infrastructure/
    adapters/
      rendering/
      persistence/
      input/
      audio/
    config/
    di/
    persistence/
    three/
  presentation/
    ui/
    controllers/
    hooks/
    state/
  shared/
    kernel/
    utils/
    types/
  tests/
    unit/
      domain/
      application/
    contract/
    integration/
    e2e/
```
- `<bounded-context>` 配下はドメイン言語単位で切り出し、各文脈が `aggregates` や `services` を独立保守できる構造とする。
- `application/usecases` はユースケースの意図（コマンド／クエリ）別に整理し、入出力 DTO を `dto` で管理する。
- `infrastructure/adapters` はポート実装を技術カテゴリで束ね、設定値や DI 構成は `config`・`di` に集約する。
- `presentation` はユーザー入力と表示の責務に限定し、アプリケーション層ファサードと UI アダプタ間の境界を明確にする。
- `tests` では契約テストを `contract` に配置し、レイヤ間の整合性検知を自動化する。

## レイヤ別実装ガイド
### ドメイン層
- 値オブジェクトは不変・比較可能を前提に `value-objects` へ配置し、ファクトリ関数で生成過程を統一する。
- 集約（`aggregates`）はルート単位でフォルダを分け、状態遷移をドメインイベントで表現する。
- ポート定義は `ports` に Interface を配置し、戻り値は `dto` 相当の純データ構造を使用する。
- ドメインサービスは Pure Function もしくは依存注入可能なクラスで表現し、副作用はポート経由に限定する。

### アプリケーション層
- ユースケースは `usecases/commands`（状態変更）と `usecases/queries`（参照）に分類し、単一責務で記述する。
- ファサードは UI から利用される公開 API として `facades` に配置し、ユースケースを委譲する。
- DTO マッピングは `mappers` に集約し、ドメイン値オブジェクトとの相互変換を明文化する。
- ユースケース内ではドメインポートを依存として受け取り、例外はドメイン定義のエラー型にラップする。

### インフラ層
- `adapters` 配下でポート実装を技術カテゴリ毎に分割し、Three.js など外部ライブラリ依存はここで完結させる。
- 設定値・環境依存は `config` にまとめ、DI コンテナから参照できるようにする。
- `di` には依存注入の登録スクリプトを配置し、アプリケーション層からは抽象ファクトリを介してアクセスする。
- 外部 API やストレージへのアクセスはリトライ方針やシリアライザをアダプタ内で完結させ、ドメインへ例外を漏らさない。

### プレゼンテーション層
- UI コンポーネントは `ui`、イベントハンドラ・状態管理は `controllers` や `hooks` に配置し、 Application ファサードのみを呼び出す。
- 入力検証やフォーム管理はプレゼンテーション層で完結させ、ドメインに渡す前に DTO へ変換する。
- 表示用の ViewModel を導入する場合は `state` でユースケース結果を整形し、副作用はファサード越しに処理する。

### 共有・テスト層
- `shared/kernel` に cross-layer で利用する基盤ユーティリティ（ログ、設定読み込み等）を配置する。
- テストは契約・統合・ E2E の順に粒度を上げ、共通フィクスチャやテストダブルは `tests/shared` で再利用する。
- 依存方向を検査するスクリプトや ESLint ルールは `scripts` もしくは `config` へ配置し、CI での自動検証に備える。

## 実装ガイドライン詳細
### ポート／アダプタ実装手順
1. ドメインサービスが外部リソースへ依存している箇所を洗い出し、責務単位でポート Interface を `domain/<context>/ports` に定義する。
2. ポートの入出力をドメイン DTO として `domain/<context>/dto` または `application/dto` に追加し、型を共有する。
3. `infrastructure/adapters/<tech>/` にポート実装を配置し、外部ライブラリの初期化をアダプタ内で完結させる。
4. アダプタは `di/container.ts`（新設）で登録し、 Application 層ユースケースに注入する。
5. 契約テストを `tests/contract/<port>` に追加し、アダプタがポート契約を満たすことを検証する。

### ユースケース実装手順
1. ユースケースのトリガ（UI イベントやシステムイベント）を整理し、期待する入力／出力 DTO を `application/dto` に定義する。
2. `application/usecases/commands` または `queries` にクラス／関数を追加し、 execute メソッドにビジネスフローを記述する。
3. ドメインサービス／ポートをコンストラクタ注入し、副作用はポート呼び出しに限定する。
4. 成功・失敗の戻り値は Result 型や Either を利用し、プレゼンテーション層に伝搬しやすい形に正規化する。
5. ユースケース単位の統合テストを `tests/integration/application` に追加し、プレゼンテーション層と切り離して検証する。

### 依存注入と設定
- `infrastructure/di/container.ts` をエントリポイントとし、アダプタ登録と設定読み込みを一元化する。
- プレゼンテーション層のエントリ（例: `src/main.ts`）では DI コンテナからアプリケーションファサードを取得し、 UI へ渡す。
- 設定値は `.env` や JSON を `config` で管理し、環境別設定は `config/environments/<env>.ts` へ切り出す。
- 循環依存を防ぐため、 DI コンテナで抽象 Interface をキーに登録し、具体実装はインフラ層に限定する。

### テストと静的検証
- 契約テストはポートインターフェースをモック化せず、実アダプタとテストダブルの外部サービスで整合性を確認する。
- レイヤ依存チェックは `scripts/check-deps.ts` を追加し、 `madge` などで循環と依存方向を検証する。
- 型チェックは `tsconfig.json` を `references` 付きのプロジェクトリファレンス構造に変更し、レイヤ毎に `tsconfig.*.json` を用意する。
- ESLint/TSLint 等で `no-restricted-imports` を用い、ドメイン側からインフラ層への直接参照を禁止する。

## 対象外
- 新規ゲームロジックの追加や仕様変更。
- デプロイパイプラインや CI/CD 設定の刷新。
- Three.js 自体のバージョンアップや最適化対応。

## 前提条件
- 現状のレイヤ構造と主要なユースケースフローを把握しているメンバーがアサインされる。
- 既存テストがローカルで再現可能であり、必要に応じて追加テストを実行できる。
- ドメインモデルのユビキタス言語が定義済みで、命名変更の判断ができる。

## 現状課題
1. ドメイン層が Three.js, DOM API, 永続化ストレージへ直接アクセスしており、集約の不変条件検証が技術的実装に依存している。
2. `*Live` 実装や Effect Layer がドメイン配下に存在し、ポートとアダプタの分離が成立していない。
3. 環境検出や永続化戦略がドメイン層に散在し、条件分岐の複雑さがビジネスロジックを汚染している。
4. アプリケーション層に定義されるべきユースケースがプレゼンテーションやインフラ層へ分散し、オーケストレーションが見えづらい。
5. 型チェックとテスト範囲が `src/domain/block/**/*` に限定され、レイヤ間契約の退行検知が困難。

## ステークホルダーと責任
| 区分 | 主責任 | 主担当タスク |
| --- | --- | --- |
| テックリード | 方針決定・レビュー承認 | フェーズ進行判断・設計レビュー |
| ドメイン担当 | ドメインモデル整理 | ポート定義、ユビキタス言語維持 |
| アプリ担当 | ユースケース再設計 | サービス層実装とファサード整備 |
| インフラ担当 | アダプタ再実装 | Three.js, 永続化アダプタ、設定 |
| QA/テスト | 品質保証 | テスト拡充、契約テストケース作成 |

## コミュニケーションとレビュー
- フェーズ開始時にキックオフを実施し、対象領域と完了条件を確認する。
- 各フェーズ完了時にペアレビュー（テックリード + 該当担当）で差分を精査する。
- フェーズ横断課題は週次で改善ログに記録し、次フェーズ計画へ反映する。
- 破壊的変更が発生する場合は、実装前に ADR を簡潔に作成し共有する。

## 実行方針
- ドメイン層ではインターフェース・値オブジェクト・ドメインサービス契約のみを保持し、副作用を伴う処理を排除する。
- インフラ層へ Live 実装を再配置し、Three.js・ブラウザ API・永続化実装・環境判定等の技術的詳細を集約する。
- アプリケーション層にユースケース／ファサードを整備し、プレゼンテーション層にはアダプタ実装のみを残す。
- 依存注入は Bootstrap 層ではなく Infrastructure 層中心に構築し、Application 層がドメインポートを受け取る形へ刷新する。
- 型チェックとテスト範囲を全レイヤに拡張し、回帰を早期に検知する。

## フェーズ別アクション
### フェーズ1: ドメイン層の隔離
- **主タスク**
  - Camera, Inventory, Chunk 周辺で外部 API を直接利用している箇所をリスト化し、責務を判定する。
  - ドメイン層にポート（例: `CameraPort`, `ContainerPersistencePort`）とドメイン DTO を定義し、戻り値・引数を再設計する。
  - `*Live` 実装と Effect Layer を削除または移動し、ドメイン層には契約のみを残す。
- **成果物**
  - ポート一覧と責務対応表。
  - リファクタリング後のドメイン層コード差分。
- **実装方法**
  1. `rg` で Three.js や `window` 等のキーワードを検索し、ドメイン層からの技術依存箇所を列挙する。
  2. 各箇所についてドメイン概念を整理し、必要な入力・出力をドメイン DTO として定義する。
  3. 既存の `*Live` 実装を `infrastructure/adapters` へ移動させる前段として、 Interface を `domain/<context>/ports` に追加する。
  4. ドメインサービスからはポート Interface のみを参照するよう書き換え、副作用を除去する。
- **完了条件**
  - ドメイン層から外部ライブラリへの直接参照が存在しない。
  - ポート経由でのみ技術的依存が解決されている。

### フェーズ2: インフラ層の再配置
- **主タスク**
  - フェーズ1で切り出したポートに対するアダプタを `src/infrastructure` 配下で実装する。
  - Three.js, IndexedDB, LocalStorage 等の環境依存処理をアダプタにまとめ、設定値をインフラ層で一元管理する。
  - 環境検出や永続化戦略分岐を Infrastructure のコンフィギュレーションへ集約する。
- **成果物**
  - ポート別アダプタ実装と設定ファイル。
  - 環境依存一覧とアダプタ対応表。
- **実装方法**
  1. フェーズ1で定義したポートを基に、 `infrastructure/adapters/<tech>` にクラス／ファクトリを作成する。
  2. アダプタ内部で外部ライブラリ初期化を行い、例外をドメイン定義のエラー型へ変換する。
  3. `infrastructure/di/container.ts` にアダプタ登録を追加し、設定値は `infrastructure/config` から読み込む。
  4. 契約テストを `tests/contract` に用意し、ポート Interface と実装の整合性を検証する。
- **完了条件**
  - インフラ層からドメイン層への依存がポート経由に限定される。
  - プレゼンテーション層が直接技術的詳細へ触れない。

### フェーズ3: アプリケーション層のユースケース再設計
- **主タスク**
  - ゲーム起動／停止、シーン遷移、入力処理など主要ユースケースを洗い出し、 Application 層サービスへ再配置する。
  - Application 層でドメインポートを注入し、プレゼンテーション層にはファサード API を提供する。
  - Bootstrap での Layer 組み立てを簡素化し、 Infrastructure が提供する Layer を Application へ供給する構成へ統一する。
- **成果物**
  - ユースケース一覧と依存ポート図。
  - Application 層サービスコードとファサード API ドキュメント。
- **実装方法**
  1. 既存 UI ハンドラとゲームループ処理を棚卸しし、ユースケース単位のイベントシーケンスを作成する。
  2. `application/usecases` にコマンド／クエリを実装し、必要なポートをコンストラクタ注入する。
  3. `application/facades` でユースケースを束ね、 UI へ公開する関数群を定義する。
  4. 変更後のフローを `docs` などでシーケンス図として更新し、レビュー時の理解を支援する。
- **完了条件**
  - プレゼンテーション層が Application 層ファサードのみに依存する。
  - ユースケース単位でユビキタス言語が反映される。

### フェーズ4: テストと型チェック拡充
- **主タスク**
  - tsconfig の `include` 範囲を `src` 全体へ広げ、型チェック設定を調整する。
  - ポート毎の契約テスト／単体テストを整備し、 Infrastructure アダプタとの整合性を担保する。
  - ユースケース単位の統合テストを追加し、プレゼンテーション層からドメイン層までのシナリオを検証する。
- **成果物**
  - 更新された tsconfig とテストコード。
  - テストカバレッジレポートと回帰防止リスト。
- **実装方法**
  1. `tsconfig.json` をプロジェクトリファレンス構成に更新し、レイヤ毎の `tsconfig.*.json` を追加する。
  2. 契約テスト・統合テスト・ E2E テストを追加し、 `pnpm test` でレイヤ横断の検証を自動化する。
  3. `scripts/check-deps.ts` を追加し、 `madge` による依存方向チェックを CI へ組み込む。
  4. カバレッジ閾値を設定し、主要ユースケースが網羅されていることを確認する。
- **完了条件**
  - CI テストでレイヤ侵食が検出できる。
  - テスト失敗時に原因レイヤが特定可能である。

### フェーズ5: リリース準備と振り返り
- **主タスク**
  - 変更点をまとめた開発者向けガイドを作成し、リリースノート下書きを共有する。
  - 実装者・レビュアーで振り返りを行い、以降の改善タスクを棚卸しする。
- **成果物**
  - ガイドラインと残課題リスト。
  - 改善ログと次期アクション候補。
- **実装方法**
  1. フェーズ 1〜4 の成果と残課題をテンプレート化し、 `docs/adr` へ反映する。
  2. アプリケーション層のファサード API 変更点をまとめたチートシートを作成し、プレゼンテーション担当へ展開する。
  3. 残課題は Issue 化し、優先度・担当・完了条件を明記して次期スプリントへ引き継ぐ。
- **完了条件**
  - 既知の残課題がチケット化され、次期スプリントで扱える状態になっている。

## リスクと対応策
- **ユースケースの抜け漏れ**: 既存イベントログやプレゼンテーション層のハンドラを網羅的に棚卸しし、チェックリスト化する。
- **三層間の循環依存復活**: 依存方向を自動検証するスクリプト（例: `madge`）を導入し、CI に組み込む。
- **ドメインモデルの肥大化**: 値オブジェクト化の基準を策定し、レビュー時に逸脱を検知する。
- **テストコストの増大**: 契約テストを最小構成から開始し、優先度に応じて段階的に拡張する。

## 成果物と合否判定基準
- ドメイン層の `import` が自層または抽象ポートのみに限定される。
- Infrastructure 層にポート実装が集約され、 Three.js やストレージ API へのアクセスが移される。
- Application 層のユースケースファサードが明確になり、プレゼンテーション層はそれらのみに依存する。
- tsconfig とテストスイートが全レイヤをカバーし、 CI でドメイン侵食が検出できる仕組みが整っている。
- 以上の条件が各フェーズ完了レビューで満たされているとテックリードが判断した時点で計画完了とする。
