# 使用技術 (Technologies)

本プロジェクトで採用している主要なライブラリ、フレームワーク、ツールについて解説します。

---

## 1. コアライブラリ

### [Effect](https://effect.website/)

- **役割**: アプリケーション全体のアーキテクチャの根幹。
- **概要**: TypeScriptのための関数型プログラミングエコシステム。単なるライブラリではなく、堅牢でスケーラブルなアプリケーションを構築するための包括的なフレームワークです。
- **採用理由**:
  - **副作用の厳密な管理**: `src/infrastructure`層で行われるDOM操作、Workerとの通信、Three.jsの呼び出しといった副作用を`Effect`データ型にカプセル化しています。これにより、`src/systems`層のゲームロジックを純粋な関数として記述でき、テスト容易性と予測可能性を劇的に向上させています。
  - **構造化された並行処理**: `Fiber`をベースにした高度な並行・非同期処理を活用しています。例えば、`src/systems/chunk-loading.ts`では、複数のチャンク生成Workerへのタスク発行を`Effect.fork`を用いてノンブロッキングに実行しています。
  - **依存性注入 (DI)**: `Layer`と`Context`を用いた強力なDIシステムは`src/main.ts`で集中的に使用され、`World`や`Renderer`といったサービスの具体的な実装（Live版）をアプリケーション全体に提供しています。
  - **エコシステム**: `Ref`（`src/runtime/world.ts`での状態管理）、`Queue`（`src/runtime/render-queue.ts`でのコマンド伝達）など、豊富なツールがプロジェクトの随所で活用されています。

### [@effect/schema](https://effect.website/docs/guides/schema/schema)

- **役割**: データモデリングとバリデーション。
- **概要**: Effectエコシステムの一部であり、TypeScriptの型定義からランタイムのバリデーション、エンコード/デコードスキーマまでを一度に生成できる強力なツールです。
- **採用理由**:
  - **ECSのコンポーネント定義**: プロジェクトの核となるECSのコンポーネントは`src/domain/components.ts`ですべて`Schema.Class`を用いて定義されています。これにより、コンポーネントのデータ構造が静的にも動的にも保証されます。
  - **不変性の強制**: `Schema`から生成される型はデフォルトで`Readonly`であり、意図しないデータ変更を防ぎ、関数型プログラミングの原則をサポートします。
  - **セーブ/ロード機能**: `src/runtime/save-load.ts`で定義された`SaveState`スキーマは、ゲームの状態をJSONとして安全にシリアライズ・デシリアライズする上で中心的な役割を果たします。

### [Three.js](https://threejs.org/)

- **役割**: 3Dレンダリングエンジン。
- **概要**: WebGLを抽象化し、3Dシーン、カメラ、メッシュ、マテリアルなどを簡単に操作できるようにする、Webで最も広く使われている3Dライブラリです。
- **採用理由**:
  - **実績とコミュニティ**: 豊富なドキュメント、サンプル、そして巨大なコミュニティが存在し、問題解決が容易です。
  - **パフォーマンス**: `src/infrastructure/renderer-three/render.ts`では、多数のブロックを効率的に描画するために`InstancedMesh`を活用しています。
  - **柔軟性**: レンダリングに関する具体的な実装は`infrastructure`層に完全にカプセル化されており、Three.jsの機能を直接的かつ強力に利用しつつも、他のシステムからは抽象化されています。

### [@react-three/drei](https://github.com/pmndrs/drei)

- **役割**: Three.jsのためのヘルパーライブラリ。
- **概要**: `@react-three/drei`は、Three.jsの一般的なシーンオブジェクトやエフェクト、コントローラーなどを、再利用可能なコンポーネントとして提供するライブラリ群です。Reactコンポーネントとして提供されていますが、本プロジェクトではReactを直接使用していないため、その一部のユーティリティ関数やロジックを参考にしたり、部分的に利用したりしています。
- **採用理由**:
  - **実績のある実装**: カメラ制御やポインターロックなど、3Dアプリケーションで一般的に必要となる機能について、高品質でテスト済みの実装を提供しており、開発の効率を高めます。
  - **学習リソース**: たとえ直接利用しない場合でも、そのソースコードはThree.jsを使った高度な実装の優れた参考資料となります。

---

## 2. 開発ツールとユーティリティ

### [Vite](https://vitejs.dev/)

- **役割**: フロントエンドのビルドツール兼開発サーバー。
- **採用理由**: HMR（ホットモジュールリプレースメント）による非常に高速な開発サイクルと、シンプルな設定でTypeScriptやWeb Workerを含むモダンな開発環境を構築できるため。また、`vite.config.ts`で`Cross-Origin-Opener-Policy`と`Cross-Origin-Embedder-Policy`ヘッダーを設定することにより、Web Workerで`SharedArrayBuffer`の使用を可能にし、メインスレッドとワーカースレッド間のデータ転送のオーバーヘッドを削減しています。

### [TypeScript](https://www.typescriptlang.org/)

- **役割**: 静的型付け言語。
- **採用理由**: 大規模なコードベースの保守性を高め、多くのエラーをコンパイル時に防ぐことができるため。`tsconfig.json`で`strict`モードをはじめとする多数の厳格なオプションを有効化しており、Effect-TSの能力を最大限に活かす上で必須です。

### [Oxlint](https://oxc-project.github.io/docs/guide/linter.html)

- **役割**: JavaScript/TypeScript リンター。
- **採用理由**: Rustで書かれており、非常に高速な静的解析を提供します。`package.json`の`lint`スクリプトで定義されており、コードの潜在的なバグや一貫性のないパターンをCI/CDパイプラインで迅速に検出します。

### [BiomeJS](https://biomejs.dev/)

- **役割**: コードフォーマッタ。
- **採用理由**: `package.json`の`format`スクリプトで定義されており、コードスタイルをプロジェクト全体で統一するために使用されます。Oxlint同様Rust製で非常に高速であり、フォーマットとリンティングのツールチェーンを高速なものに統一しています。

### [Immer](httpss://immerjs.github.io/immer/)

- **役割**: 不変な状態(Immutable State)の操作。
- **概要**: `immer`は、状態を変更するロジックを簡潔に書くことで、複雑な不変なデータ構造の更新を容易にするライブラリです。直接オブジェクトを書き換えるようなコード（ミューテーション）を書いても、安全な更新処理に変換してくれます。
- **採用理由**: 本プロジェクトでは直接的にコード内で使用されている箇所は少ないですが、`@react-three/drei`のようなUI関連の依存ライブラリの内部で広く活用されています。これにより、UIの状態管理などが安全かつ効率的に行われます。また、テストコード(`src/vitest.setup.ts`)でも`Map`や`Set`を扱えるように設定されており、テストの信頼性を高めています。

### [ - **採用理由**: `src/infrastructure/input-browser.ts`でのキーボード入力イベントの処理や、複雑な状態を持つシステムのユニットテストなどで活用されています。`if/else`や`switch`文のネストを避け、条件分岐を宣言的かつ可読性高く記述できるため、コードの保守性向上に貢献します。

### [simplex-noise](httpss://github.com/jwagner/simplex-noise.js), [perlin-noise](https://www.npmjs.com/package/perlin-noise) & [alea](https://www.npmjs.com/package/alea)

- **役割**: プロシージャルな地形生成。
- **概要**: `simplex-noise` と `perlin-noise` は、自然な地形を生成するためのノイズ関数ライブラリです。`alea`はシード可能な乱数生成器(PRNG)です。
- **採用理由**: `src/workers/computation.worker.ts`の地形生成ロジックで使用されています。これらのノイズ関数を用いることで自然で滑らかな地形を生成し、`alea`と組み合わせることで、同じシード値からは常に同じワールドが生成される、再現性のあるワールド生成を実現しています。

### [Texture Atlas Script](scripts/create-texture-atlas.cjs)

- **役割**: テクスチャアトラスの生成。
- **概要**: `scripts/create-texture-atlas.cjs` は、`public/assets`内の個別のブロックテクスチャを一枚のテクスチャアトラスにまとめるNode.jsスクリプトです。
- **採用理由**: 複数のテクスチャを一つにまとめることで、GPUへのテクスチャのバインディング回数を削減し、レンダリングパフォーマンスを向上させます。

### [stats.js](https://github.com/mrdoob/stats.js/)

- **役割**: パフォーマンスモニタリング。
- **概要**: FPSやメモリ使用量をリアルタイムで画面上に表示する軽量なパフォーマンスモニターです。
- **採用理由**: `src/runtime/loop.ts`で統合されており、開発中にパフォーマンスのボトルネックを特定し、最適化を行うための重要な指標を提供します。

### [file-saver](https://github.com/eligrey/FileSaver.js/)

- **役割**: ファイル保存機能。
- **概要**: クライアントサイドでファイルを生成し、ユーザーのデバイスに保存するためのライブラリです。
- **採用理由**: ゲームワールドの状態をJSONファイルとしてエクスポートするセーブ機能 (`src/runtime/save-load.ts`) で使用されています。

### [uuid](https://github.com/uuidjs/uuid)

- **役割**: 一意なIDの生成。
- **概要**: RFC4122に準拠したUUIDを生成します。
- **採用理由**: `src/domain/types.ts`で定義されており、ECSにおける各エンティティに、衝突の可能性が極めて低い一意なIDを割り当てるために使用されます。

---

## 3. テスティング

### [Vitest](https://vitest.dev/)

- **役割**: テストランナー。
- **概要**: Viteネイティブの高速なテストフレームワーク。
- **採用理由**:
  - **高速性**: Viteのエンジンを活用し、テストの実行とフィードバックが非常に高速です。
  - **設定の容易さ**: `vite.config.ts`を共有するため、テスト固有の複雑な設定が不要です。
  - **DOMテスト環境**: `happy-dom` を利用してNode.js環境内にDOM環境をシミュレートし、ブラウザに依存しない高速なUIロジックのテストを可能にしています。
  - **Effectとの連携**: `Effect.runPromise`を使用することで、Effectで書かれたプログラムをユニットテスト内で簡単に実行できます（例: `src/runtime/world.test.ts`）。

### [fast-check](https://fast-check.dev/)

- **役割**: プロパティベーステストライブラリ。
- **概要**: 事前に定義したプロパティ（不変条件）に基づき、ランダムなデータを大量に自動生成してテストを実行します。
- **採用理由**:
  - **網羅性の向上**: `src/domain/components.test.ts`では、各コンポーネントスキーマが任意の有効なデータに対して正しくエンコード・デコードできることを保証するために使用されています。これにより、開発者が想定しないエッジケースを自動的に発見できます。

### [@vitest/ui](https://vitest.dev/guide/ui.html)

- **役割**: インタラクティブなテストUI。
- **概要**: テストの実行結果をブラウザ上で視覚的に確認できるUIを提供します。
- **採用理由**: テストのフィルタリング、結果の分析、デバッグが容易になります。