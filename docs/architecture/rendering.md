# レンダリング (Rendering)

このドキュメントでは、Three.js を利用した本プロジェクトのレンダリングパイプラインと、パフォーマンス最適化に関するアプローチについて解説します。

## 1. 基本アーキテクチャ

レンダリングに関する責務は、以下の3つの主要な部分に分割されています。

1.  **`RenderQueue` サービス (`src/runtime/services.ts`)**:
    -   レンダリングコマンドを非同期に受け取るためのキューです。`Effect.Queue` として実装されています。
    -   `sceneSystem` は、エンティティの追加・更新・削除といった描画関連の操作を、具体的なコマンドオブジェクト (`UpsertEntity`, `RemoveEntity`) としてこのキューに追加します。

2.  **`RendererThree` 実装 (`src/infrastructure/renderer-three.ts`)**:
    -   Three.js の `WebGLRenderer`, `Scene`, `Camera` などを管理するサービスです。
    -   アプリケーションの起動時に `RenderQueue` をリッスンし、キューから受け取ったコマンドに基づいて Three.js のシーンを実際に操作します。
    -   `Effect.Layer` として提供され、`main.ts` でアプリケーション全体に注入されます。

3.  **`sceneSystem` (`src/systems/scene.ts`)**:
    -   ECSのシステムとして、毎フレーム実行されるレンダリングロジックを担当します。
    -   `World` から `Position` や `Renderable` といった描画に必要なコンポーネントを持つエンティティをクエリします。
    -   前フレームの状態と比較し、どのエンティティが追加/更新/削除されたかを判断します。
    -   その差分をコマンドとして `RenderQueue` に送信します。

このアーキテクチャにより、ゲームロジック（`sceneSystem`）と実際の描画処理（`RendererThree`）が疎結合になり、関心の分離が徹底されています。

## 2. ブロックのレンダリングと最適化

Minecraftライクなゲームでは、膨大な数のブロック（キューブ）を効率的に描画することがパフォーマンス上の最大の課題となります。本プロジェクトでは、以下の手法を用いてこれを解決しています。

### `InstancedMesh` の活用

-   **概要**: `InstancedMesh` は、同じジオメトリ（形状）とマテリアル（材質）を持つ多数のオブジェクトを、一度の描画命令（ドローコール）でまとめてレンダリングするための Three.js の機能です。
-   **実装**:
    -   ブロックの種類ごと（現在は色で区別）に `InstancedMesh` を一つ用意します。例えば、「草ブロック用」「土ブロック用」「石ブロック用」の `InstancedMesh` がそれぞれ存在します。
    -   `RendererThree` は、`RenderQueue` から受け取ったコマンドに基づき、対応する `InstancedMesh` のインスタンス行列（`setMatrixAt`）を更新します。
    -   これにより、ワールド内に数万個のブロックがあっても、ドローコールの回数はブロックの種類数と同じ、ごくわずかな数に抑えられます。

### チャンク単位での管理

-   描画対象となるブロックは、プレイヤーの周囲にあるチャンク（16x16x16などのブロックの塊）内のものに限定されます。
-   `chunk-loading` システムがプレイヤーの位置に基づいて描画すべきチャンクを決定し、`sceneSystem` はその範囲内のブロックのみを描画対象とします。
-   これにより、ワールド全体のブロック数に関わらず、常に一定の描画負荷を維持できます。

## 3. 描画パイプライン

毎フレームの描画は、以下の流れで実行されます。

1.  **`loop.ts`**: ゲームループが `sceneSystem` を呼び出します。
2.  **`sceneSystem`**:
    -   `World` から、現在ロードされているチャンク内のすべてのブロックエンティティをクエリします。
    -   前フレームのエンティティリストと比較し、差分（追加・削除されたエンティティ）を検出します。
    -   差分情報を `UpsertEntity` または `RemoveEntity` コマンドとして `RenderQueue` に送信します。
3.  **`RendererThree`**:
    -   （バックグラウンドで）`RenderQueue` を継続的に監視しています。
    -   コマンドを受け取ると、対応する `InstancedMesh` の状態を更新します。
    -   `three.WebGLRenderer.render(scene, camera)` を `requestAnimationFrame` ループで実行し、最終的な描画をWebGLキャンバスに行います。

## 4. 今後の展望と課題

-   **Greedy Meshing**: 隣接する同じ種類のブロックを一つの大きなメッシュに統合することで、頂点数を削減し、さらなるパフォーマンス向上を目指します。
-   **テクスチャアトラス**: すべてのブロックのテクスチャを一枚の画像にまとめることで、マテリアルの切り替えコストを削減します。
-   **ライティングとシェーダー**: 現状は基本的なライティングのみですが、影や環境光などを表現するカスタムシェーダーを導入し、ビジュアル品質を向上させます。
