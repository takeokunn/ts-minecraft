# レンダリングの最適化手法

広大なボクセルワールドをリアルタイムで描画するには、パフォーマンスを極限まで高めるための最適化が不可欠です。本プロジェクトでは、主に**地形（静的オブジェクト）**と**動的オブジェクト**の2種類に対して、それぞれ異なる最適化手法を適用しています。

-   **関連ソース**: [`src/workers/computation.worker.ts`](../../src/workers/computation.worker.ts), [`src/infrastructure/renderer-three.ts`](../../src/infrastructure/renderer-three.ts)
-   **関連アーキテクチャ**: [レンダリングアーキテクチャ](../architecture/rendering.md)

---

## 1. 地形の最適化: Greedy Meshing

地形は何百万ものブロックで構成されるため、そのまま描画するとパフォーマンスが破綻します。この問題を解決するのが **Greedy Meshing** アルゴリズムです。

### 課題

単純にブロックをキューブとして描画すると、以下の問題が発生します。
-   **膨大な頂点数**: 1つのキューブは12個の三角形（36頂点）を持ちます。1チャンク（16x256x16）がすべて埋まっていると、約230万頂点にもなります。
-   **不要な内部面の描画**: 地中に埋まっているブロックの面など、プレイヤーから絶対に見えない面も描画してしまい、GPUに多大な負荷がかかります。

### 解決策

Greedy Meshingは、隣接する同じ種類のブロックを検出し、それらを一つの大きな面（ポリゴン）に統合します。

-   **仕組み**:
    1.  チャンクデータを3次元のスライス（XY, YZ, XZ平面）で走査します。
    2.  各スライスで、同じ種類のブロックが連続する長方形の領域を探索します（これが"Greedy"の名前の由来です）。
    3.  見つかった最大の長方形を一つの面としてメッシュデータ（頂点、インデックス、UV）を生成します。
    4.  探索済みの領域にはマークを付け、スキャンを続けます。
-   **効果**:
    -   **頂点数の劇的な削減**: チャンクの内部面がすべて削除され、表面のメッシュのみが生成されるため、GPUに送信するデータ量が90%以上削減されます。
    -   **ドローコールの削減**: チャンク全体が単一（または数個）のメッシュになるため、1チャンクあたり1回のドローコールで描画が完了します。

### 実装

この計算は非常に負荷が高いため、メインスレッドのフレームレートに影響を与えないよう、[`computation.worker.ts`](../../src/workers/computation.worker.ts)内のWeb Workerで完全に非同期に実行されます。

---

## 2. 動的オブジェクトの最適化: InstancedMesh

プレイヤーやMOBなど、ワールド内を移動するオブジェクトにはGreedy Meshingは適用できません。これらのオブジェクトに対しては **Instanced Rendering** という手法を用います。

-   **課題**: 複数のプレイヤーやMOBを描画する際、それぞれを個別の描画命令（ドローコール）で描画すると、CPUからGPUへの命令発行がボトルネックになります。
-   **解決策**: Three.jsの `InstancedMesh` を使用します。これは、同じ形状と材質を持つ多数のオブジェクトを、**一度のドローコール**でまとめてレンダリングする機能です。
-   **仕組み**:
    1.  オブジェクトの種類ごと（例: `player`, `item`）に `InstancedMesh` を用意します。
    2.  各インスタンスの位置、回転、スケール情報を行列 (`Matrix4`) として `InstancedMesh` に設定します。
    3.  `RendererThree` は、毎フレーム、動的オブジェクトの `Position` コンポーネントなどから最新の行列を計算し、`InstancedMesh` を更新します。

これにより、ワールド内に多数の動的オブジェクトが存在しても、ドローコールの回数をオブジェクトの種類数まで抑えることができ、高いパフォーマンスを維持します。
