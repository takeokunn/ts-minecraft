# パフォーマンス設計 (Performance Design)

このプロジェクトは、Webブラウザ上で大規模なボクセルの世界を滑らかに描画するという、パフォーマンスが非常に重要な要件を持っています。そのため、アーキテクチャの設計段階から、パフォーマンスを最大化するためのいくつかの重要な原則を取り入れています。

---

## 1. データ指向設計 (Data-Oriented Design)

本プロジェクトのパフォーマンス設計の核心は、**データ指向設計**の考え方に基づいています。これは、コード（ロジック）よりもデータとそのメモリレイアウトを優先して最適化するアプローチです。

### Entity Component System (ECS)

ECSアーキテクチャの採用は、データ指向設計を実現するための第一歩です。

- **Component**: 純粋なデータであり、ロジックを持ちません。
- **System**: データを処理するロジックです。

これにより、データとロジックが明確に分離され、データを効率的に処理するための最適化が可能になります。`World`の実装には**Archetype**と**Structure of Arrays (SoA)**を組み合わせることで、CPUキャッシュヒット率を劇的に向上させ、クエリを高速化しています。

詳細は [**World内部設計 (World Architecture)**](./world-performance.md) を参照してください。

---

## 2. ガベージコレクション (GC) 負荷の最小化

JavaScript/TypeScriptは自動的にメモリ管理を行いますが、そのプロセス（ガベージコレクション）はフレームレートの低下（ジャンク）を引き起こす主要な原因です。本プロジェクトでは、GCの発生を可能な限り抑えるための規約を設けています。

### ループ内でのオブジェクト生成の禁止

毎フレーム実行されるシステムのループ内で、`new MyObject()` のようなオブジェクト生成や `{}` のようなオブジェクトリテラルを使用することは、原則として禁止されています。

- **悪い例 (Bad Practice)**:

  ```typescript
  for (let i = 0; i < entities.length; i++) {
    const newVel = new Velocity({ ... }); // ループごとに新しいオブジェクトが生成される
    world.updateComponent(id, newVel);
  }
  ```

- **良い例 (Good Practice)**:
  ```typescript
  for (let i = 0; i < entities.length; i++) {
    const newDy = calculateNewVelocityY(...);
    // SoAストアの配列を直接更新する
    velocities.dy[i] = newDy;
  }
  ```

### `querySoA` APIの強制

`World`からデータを取得する際には、**`querySoA` APIのみを使用します**。これは、クエリ結果をJavaScriptのオブジェクトとしてではなく、内部ストレージの配列への参照として返すため、余計なメモリアロケーションが発生しません。

### オブジェクトプーリング (将来的な展望)

現在、Three.jsの`Vector3`や`Matrix4`など、一部のオブジェクトは依然として生成されています。将来的には、これらの頻繁に使用されるオブジェクトに対してオブジェクトプーリングを導入し、GC負荷をさらに削減することを検討しています。

---

## 3. Effect-TSによる効率的な並行処理

[Effect-TS](https://effect.website/)は、単なる型安全なエラーハンドリングのツールではありません。`Effect.all`や`Effect.forEach`といったコンビネータは、依存関係のない処理を効率的に並行実行するためのスケジューリング機能を提供します。

```typescript
// 複数のチャンクを並行してアンロードする
yield * _(Effect.all(unloadingEffects, { discard: true, concurrency: 'inherit' }))
```

これにより、マルチコアCPUの性能を最大限に活用し、特にチャンクのロード/アンロードのような重い処理をメインスレッドをブロックすることなく実行できます。

---

## 4. レンダリングの最適化

### InstancedMesh

Minecraftライクなゲームでは、膨大な数のブロックを描画する必要があります。個別の`THREE.Mesh`を何万個も作成する代わりに、`THREE.InstancedMesh`を使用します。これにより、同じジオメトリとマテリアルを持つすべてのブロックを、一度の描画命令（ドローコール）でレンダリングできます。ドローコールの回数がブロックの種類数まで削減され、パフォーマンスが劇的に向上します。詳細は[レンダリング](./rendering.md)のドキュメントを参照してください。
