#!/usr/bin/env node

/**
 * プロジェクトクリーンアップコマンド
 * 使用法: /project-clean [--deep] [--confirm]
 * 機能: 不要ファイル削除、依存関係クリーンアップ、キャッシュクリア
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class ProjectCleaner {
  constructor() {
    this.deepClean = process.argv.includes('--deep');
    this.autoConfirm = process.argv.includes('--confirm');
    this.language = this.detectLanguage();
    this.packageManager = this.detectPackageManager();
    this.filesToDelete = [];
    this.dirsToDelete = [];
    this.commandsToRun = [];
  }

  detectLanguage() {
    if (fs.existsSync('package.json')) return 'javascript';
    if (fs.existsSync('pyproject.toml') || fs.existsSync('requirements.txt')) return 'python';
    if (fs.existsSync('Cargo.toml')) return 'rust';
    if (fs.existsSync('go.mod')) return 'go';
    return 'javascript';
  }

  detectPackageManager() {
    if (fs.existsSync('pnpm-lock.yaml')) return 'pnpm';
    if (fs.existsSync('yarn.lock')) return 'yarn';
    if (fs.existsSync('bun.lockb')) return 'bun';
    return 'npm';
  }

  async clean() {
    console.log(`🧹 プロジェクトクリーンアップ開始 (${this.deepClean ? 'ディープクリーニング' : '標準クリーニング'})`);

    this.identifyCleanupTargets();
    await this.showCleanupPlan();

    if (!this.autoConfirm) {
      const readline = require('readline');
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

      const answer = await new Promise(resolve => {
        rl.question('\n実行しますか？ (y/N): ', resolve);
      });

      rl.close();

      if (answer.toLowerCase() !== 'y' && answer.toLowerCase() !== 'yes') {
        console.log('❌ クリーンアップをキャンセルしました');
        return;
      }
    }

    await this.executeCleanup();
    this.showResults();
  }

  identifyCleanupTargets() {
    // 共通の削除対象
    const commonDirs = [
      'dist',
      'build',
      'out',
      '.vite',
      '.next',
      '.nuxt',
      'coverage',
      '.coverage',
      '.nyc_output',
      '.cache',
      'tmp',
      'temp'
    ];

    const commonFiles = [
      '.DS_Store',
      'Thumbs.db',
      '*.log',
      '*.tmp',
      '*.swp',
      '*.swo',
      '*~'
    ];

    // 言語固有の削除対象
    switch (this.language) {
      case 'javascript':
        this.dirsToDelete.push(...commonDirs, 'node_modules/.vite', 'node_modules/.cache');
        this.filesToDelete.push(...commonFiles, 'npm-debug.log*', 'yarn-error.log*');

        if (this.deepClean) {
          this.dirsToDelete.push('node_modules');
          this.commandsToRun.push(() => {
            console.log('📦 パッケージマネージャーキャッシュクリア...');
            try {
              if (this.packageManager === 'npm') {
                execSync('npm cache clean --force', { stdio: 'inherit' });
              } else if (this.packageManager === 'yarn') {
                execSync('yarn cache clean', { stdio: 'inherit' });
              } else if (this.packageManager === 'pnpm') {
                execSync('pnpm store prune', { stdio: 'inherit' });
              }
            } catch (error) {
              console.log('⚠️ キャッシュクリアでエラー:', error.message);
            }
          });
        }
        break;

      case 'python':
        this.dirsToDelete.push(...commonDirs, '__pycache__', '*.egg-info', '.pytest_cache', '.mypy_cache');
        this.filesToDelete.push(...commonFiles, '*.pyc', '*.pyo', '*.pyd');

        if (this.deepClean) {
          this.dirsToDelete.push('.venv', 'venv', '.env');
        }
        break;

      case 'rust':
        this.dirsToDelete.push(...commonDirs, 'target');
        this.filesToDelete.push(...commonFiles, 'Cargo.lock');

        if (this.deepClean) {
          this.commandsToRun.push(() => {
            console.log('🦀 Cargo キャッシュクリア...');
            try {
              execSync('cargo clean', { stdio: 'inherit' });
            } catch (error) {
              console.log('⚠️ Cargo clean でエラー:', error.message);
            }
          });
        }
        break;

      case 'go':
        this.dirsToDelete.push(...commonDirs);
        this.filesToDelete.push(...commonFiles);

        if (this.deepClean) {
          this.commandsToRun.push(() => {
            console.log('🐹 Go モジュールキャッシュクリア...');
            try {
              execSync('go clean -modcache', { stdio: 'inherit' });
            } catch (error) {
              console.log('⚠️ Go clean でエラー:', error.message);
            }
          });
        }
        break;
    }

    // エディター・IDE固有ファイル
    if (this.deepClean) {
      this.dirsToDelete.push('.vscode', '.idea');
      this.filesToDelete.push('*.sublime-*');
    }

    // 実際に存在するものだけを対象にする
    this.dirsToDelete = this.dirsToDelete.filter(dir => fs.existsSync(dir));
    this.filesToDelete = this.filesToDelete.filter(pattern => {
      // glob パターンの場合は簡易的にチェック
      if (pattern.includes('*')) {
        return true; // glob は削除時にチェック
      }
      return fs.existsSync(pattern);
    });
  }

  async showCleanupPlan() {
    console.log('\n📋 クリーンアップ計画:');

    if (this.dirsToDelete.length > 0) {
      console.log('\n📁 削除対象ディレクトリ:');
      this.dirsToDelete.forEach(dir => {
        const size = this.getDirectorySize(dir);
        console.log(`  - ${dir} ${size ? `(${this.formatBytes(size)})` : ''}`);
      });
    }

    if (this.filesToDelete.length > 0) {
      console.log('\n📄 削除対象ファイル:');
      this.filesToDelete.forEach(file => {
        console.log(`  - ${file}`);
      });
    }

    if (this.commandsToRun.length > 0) {
      console.log('\n🔧 実行コマンド:');
      console.log(`  - パッケージマネージャーキャッシュクリア`);
    }

    const totalSize = this.dirsToDelete.reduce((total, dir) => {
      return total + (this.getDirectorySize(dir) || 0);
    }, 0);

    if (totalSize > 0) {
      console.log(`\n💾 推定削除サイズ: ${this.formatBytes(totalSize)}`);
    }
  }

  async executeCleanup() {
    console.log('\n🧹 クリーンアップ実行中...');

    let deletedCount = 0;
    let deletedSize = 0;

    // ディレクトリ削除
    for (const dir of this.dirsToDelete) {
      if (fs.existsSync(dir)) {
        const size = this.getDirectorySize(dir);
        try {
          fs.rmSync(dir, { recursive: true, force: true });
          console.log(`✅ 削除: ${dir}`);
          deletedCount++;
          deletedSize += size || 0;
        } catch (error) {
          console.log(`❌ 削除失敗: ${dir} (${error.message})`);
        }
      }
    }

    // ファイル削除
    for (const pattern of this.filesToDelete) {
      try {
        if (pattern.includes('*')) {
          // 簡易的なglob処理
          const files = this.findFilesByPattern(pattern);
          for (const file of files) {
            fs.unlinkSync(file);
            console.log(`✅ 削除: ${file}`);
            deletedCount++;
          }
        } else if (fs.existsSync(pattern)) {
          fs.unlinkSync(pattern);
          console.log(`✅ 削除: ${pattern}`);
          deletedCount++;
        }
      } catch (error) {
        console.log(`❌ 削除失敗: ${pattern} (${error.message})`);
      }
    }

    // コマンド実行
    for (const command of this.commandsToRun) {
      try {
        await command();
      } catch (error) {
        console.log(`⚠️ コマンド実行エラー: ${error.message}`);
      }
    }

    console.log(`\n📊 削除完了: ${deletedCount} 項目, ${this.formatBytes(deletedSize)}`);
  }

  findFilesByPattern(pattern) {
    const files = [];
    const regex = new RegExp(pattern.replace(/\*/g, '.*'));

    const searchDir = (dir) => {
      try {
        const items = fs.readdirSync(dir);
        for (const item of items) {
          const fullPath = path.join(dir, item);
          const stat = fs.statSync(fullPath);

          if (stat.isFile() && regex.test(item)) {
            files.push(fullPath);
          } else if (stat.isDirectory() && !item.startsWith('.')) {
            searchDir(fullPath);
          }
        }
      } catch (error) {
        // ディレクトリ読み取りエラーは無視
      }
    };

    searchDir('.');
    return files.slice(0, 100); // 最大100ファイルまで
  }

  getDirectorySize(dirPath) {
    try {
      let totalSize = 0;
      const items = fs.readdirSync(dirPath);

      for (const item of items) {
        const fullPath = path.join(dirPath, item);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
          totalSize += this.getDirectorySize(fullPath);
        } else {
          totalSize += stat.size;
        }
      }

      return totalSize;
    } catch (error) {
      return 0;
    }
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  showResults() {
    console.log('\n✅ クリーンアップ完了！');
    console.log('\n🎯 次のステップ:');

    switch (this.language) {
      case 'javascript':
        console.log(`  ${this.packageManager === 'npm' ? 'npm install' : `${this.packageManager} install`} - 依存関係を再インストール`);
        break;
      case 'python':
        console.log('  pip install -e ".[dev]" - 依存関係を再インストール');
        break;
      case 'rust':
        console.log('  cargo build - プロジェクトを再ビルド');
        break;
      case 'go':
        console.log('  go mod download - モジュールを再ダウンロード');
        break;
    }

    console.log('\n🔗 関連コマンド:');
    console.log('  /project-analyze - プロジェクト再分析');
    console.log('  /deps-update - 依存関係更新');
    console.log('  /quality-setup - 品質ツール設定');
  }
}

// コマンドライン実行
if (require.main === module) {
  new ProjectCleaner().clean();
}

module.exports = { ProjectCleaner };