#!/usr/bin/env node

/**
 * æ±ç”¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ†æã‚³ãƒãƒ³ãƒ‰
 * ä½¿ç”¨æ³•: /project-analyze
 * æ©Ÿèƒ½: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã€æ§‹é€ ã€è¨­å®šã‚’åŒ…æ‹¬çš„ã«åˆ†æ
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class ProjectAnalyzer {
  constructor() {
    this.analysis = {
      language: null,
      framework: null,
      packageManager: null,
      buildTool: null,
      testFramework: null,
      linter: null,
      formatter: null,
      typeSystem: null,
      structure: {},
      dependencies: {},
      scripts: {},
      git: {},
      recommendations: []
    };
  }

  async analyze() {
    console.log('ğŸ” ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ†æé–‹å§‹...\n');

    this.detectLanguageAndFramework();
    this.detectPackageManager();
    this.detectBuildTools();
    this.detectQualityTools();
    this.analyzeProjectStructure();
    this.analyzeGitStatus();
    this.generateRecommendations();

    this.displayResults();
    return this.analysis;
  }

  detectLanguageAndFramework() {
    // package.json åˆ†æ
    if (fs.existsSync('package.json')) {
      const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      this.analysis.dependencies = pkg.dependencies || {};
      this.analysis.scripts = pkg.scripts || {};

      // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æ¤œå‡º
      if (pkg.dependencies?.react || pkg.devDependencies?.react) {
        this.analysis.framework = 'React';
      } else if (pkg.dependencies?.vue || pkg.devDependencies?.vue) {
        this.analysis.framework = 'Vue.js';
      } else if (pkg.dependencies?.angular || pkg.devDependencies?.angular) {
        this.analysis.framework = 'Angular';
      } else if (pkg.dependencies?.next || pkg.devDependencies?.next) {
        this.analysis.framework = 'Next.js';
      } else if (pkg.dependencies?.nuxt || pkg.devDependencies?.nuxt) {
        this.analysis.framework = 'Nuxt.js';
      } else if (pkg.dependencies?.svelte || pkg.devDependencies?.svelte) {
        this.analysis.framework = 'Svelte';
      } else if (pkg.dependencies?.three || pkg.devDependencies?.three) {
        this.analysis.framework = 'Three.js';
      } else if (pkg.dependencies?.effect || pkg.devDependencies?.effect) {
        this.analysis.framework = 'Effect-TS';
      }

      // è¨€èªæ¤œå‡º
      if (pkg.devDependencies?.typescript || fs.existsSync('tsconfig.json')) {
        this.analysis.language = 'TypeScript';
        this.analysis.typeSystem = 'TypeScript';
      } else {
        this.analysis.language = 'JavaScript';
      }
    }

    // Python ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¤œå‡º
    if (fs.existsSync('requirements.txt') || fs.existsSync('pyproject.toml') || fs.existsSync('setup.py')) {
      this.analysis.language = 'Python';
      if (fs.existsSync('pyproject.toml')) {
        this.analysis.packageManager = 'pip/poetry';
      }
    }

    // Rust ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¤œå‡º
    if (fs.existsSync('Cargo.toml')) {
      this.analysis.language = 'Rust';
      this.analysis.packageManager = 'cargo';
    }

    // Go ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¤œå‡º
    if (fs.existsSync('go.mod')) {
      this.analysis.language = 'Go';
      this.analysis.packageManager = 'go mod';
    }
  }

  detectPackageManager() {
    if (fs.existsSync('package-lock.json')) {
      this.analysis.packageManager = 'npm';
    } else if (fs.existsSync('yarn.lock')) {
      this.analysis.packageManager = 'yarn';
    } else if (fs.existsSync('pnpm-lock.yaml')) {
      this.analysis.packageManager = 'pnpm';
    } else if (fs.existsSync('bun.lockb')) {
      this.analysis.packageManager = 'bun';
    }
  }

  detectBuildTools() {
    const buildTools = {
      'vite.config.js': 'Vite',
      'vite.config.ts': 'Vite',
      'webpack.config.js': 'Webpack',
      'rollup.config.js': 'Rollup',
      'esbuild.config.js': 'esbuild',
      'next.config.js': 'Next.js',
      'nuxt.config.js': 'Nuxt.js'
    };

    for (const [file, tool] of Object.entries(buildTools)) {
      if (fs.existsSync(file)) {
        this.analysis.buildTool = tool;
        break;
      }
    }
  }

  detectQualityTools() {
    // Linter æ¤œå‡º
    const linters = {
      '.eslintrc.js': 'ESLint',
      '.eslintrc.json': 'ESLint',
      'eslint.config.js': 'ESLint',
      'oxlint.json': 'oxlint',
      'pyproject.toml': 'flake8/black (Python)',
      'tox.ini': 'flake8 (Python)'
    };

    for (const [file, tool] of Object.entries(linters)) {
      if (fs.existsSync(file)) {
        this.analysis.linter = tool;
        break;
      }
    }

    // Formatter æ¤œå‡º
    const formatters = {
      '.prettierrc': 'Prettier',
      '.prettierrc.json': 'Prettier',
      'prettier.config.js': 'Prettier'
    };

    for (const [file, tool] of Object.entries(formatters)) {
      if (fs.existsSync(file)) {
        this.analysis.formatter = tool;
        break;
      }
    }

    // ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æ¤œå‡º
    if (this.analysis.dependencies.jest || this.analysis.scripts.test?.includes('jest')) {
      this.analysis.testFramework = 'Jest';
    } else if (this.analysis.dependencies.vitest || this.analysis.scripts.test?.includes('vitest')) {
      this.analysis.testFramework = 'Vitest';
    } else if (this.analysis.dependencies.mocha || this.analysis.scripts.test?.includes('mocha')) {
      this.analysis.testFramework = 'Mocha';
    }
  }

  analyzeProjectStructure() {
    const structure = {};
    const importantDirs = ['src', 'lib', 'components', 'pages', 'utils', 'test', '__tests__', 'spec', 'docs'];

    importantDirs.forEach(dir => {
      if (fs.existsSync(dir)) {
        structure[dir] = this.getDirectoryStructure(dir, 2);
      }
    });

    this.analysis.structure = structure;
  }

  getDirectoryStructure(dirPath, depth = 1) {
    if (depth <= 0) return null;

    try {
      const items = fs.readdirSync(dirPath);
      const structure = {};

      items.slice(0, 10).forEach(item => {
        const fullPath = path.join(dirPath, item);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory() && !item.startsWith('.')) {
          structure[item] = this.getDirectoryStructure(fullPath, depth - 1);
        } else if (stat.isFile() && this.isImportantFile(item)) {
          structure[item] = 'file';
        }
      });

      return structure;
    } catch (error) {
      return null;
    }
  }

  isImportantFile(filename) {
    const important = ['.ts', '.tsx', '.js', '.jsx', '.vue', '.py', '.rs', '.go', '.md'];
    return important.some(ext => filename.endsWith(ext));
  }

  analyzeGitStatus() {
    try {
      this.analysis.git.hasRepo = fs.existsSync('.git');

      if (this.analysis.git.hasRepo) {
        const branch = execSync('git branch --show-current', { encoding: 'utf8' }).trim();
        const status = execSync('git status --porcelain', { encoding: 'utf8' });
        const remote = execSync('git remote get-url origin 2>/dev/null || echo "no-remote"', { encoding: 'utf8' }).trim();

        this.analysis.git.currentBranch = branch;
        this.analysis.git.hasChanges = status.length > 0;
        this.analysis.git.remote = remote !== 'no-remote' ? remote : null;
      }
    } catch (error) {
      this.analysis.git.error = error.message;
    }
  }

  generateRecommendations() {
    const recs = this.analysis.recommendations;

    // TypeScriptæ¨å¥¨
    if (this.analysis.language === 'JavaScript' && this.analysis.framework) {
      recs.push('ğŸ”§ TypeScriptã¸ã®ç§»è¡Œã‚’æ¨å¥¨ï¼ˆå‹å®‰å…¨æ€§å‘ä¸Šï¼‰');
    }

    // Linterè¨­å®šæ¨å¥¨
    if (!this.analysis.linter && this.analysis.language !== 'Python') {
      recs.push('ğŸ”§ ESLintã¾ãŸã¯oxlintã®è¨­å®šã‚’æ¨å¥¨ï¼ˆã‚³ãƒ¼ãƒ‰å“è³ªå‘ä¸Šï¼‰');
    }

    // Formatterè¨­å®šæ¨å¥¨
    if (!this.analysis.formatter) {
      recs.push('ğŸ”§ Prettierã®è¨­å®šã‚’æ¨å¥¨ï¼ˆã‚³ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆçµ±ä¸€ï¼‰');
    }

    // ãƒ†ã‚¹ãƒˆæ¨å¥¨
    if (!this.analysis.testFramework) {
      recs.push('ğŸ§ª ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®å°å…¥ã‚’æ¨å¥¨ï¼ˆVitestæ¨å¥¨ï¼‰');
    }

    // CI/CDæ¨å¥¨
    if (!fs.existsSync('.github/workflows') && this.analysis.git.hasRepo) {
      recs.push('ğŸš€ GitHub Actionsã®è¨­å®šã‚’æ¨å¥¨ï¼ˆCI/CDè‡ªå‹•åŒ–ï¼‰');
    }

    // Effect-TS ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç‰¹æœ‰ã®æ¨å¥¨äº‹é …
    if (this.analysis.framework === 'Effect-TS') {
      if (!this.analysis.dependencies['@effect/platform']) {
        recs.push('ğŸ“¦ @effect/platform ã®è¿½åŠ ã‚’æ¨å¥¨ï¼ˆEffect-TS ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ï¼‰');
      }
      if (!this.analysis.dependencies['@effect/schema']) {
        recs.push('ğŸ“¦ @effect/schema ã®è¿½åŠ ã‚’æ¨å¥¨ï¼ˆå‹å®‰å…¨ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰');
      }
    }

    // Three.js ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç‰¹æœ‰ã®æ¨å¥¨äº‹é …
    if (this.analysis.framework === 'Three.js') {
      if (!this.analysis.dependencies['@types/three']) {
        recs.push('ğŸ“¦ @types/three ã®è¿½åŠ ã‚’æ¨å¥¨ï¼ˆTypeScriptå‹å®šç¾©ï¼‰');
      }
    }
  }

  displayResults() {
    console.log('ğŸ“Š ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ†æçµæœ\n');
    console.log('='.repeat(50));

    console.log('\nğŸ”§ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯:');
    console.log(`  è¨€èª: ${this.analysis.language || 'ä¸æ˜'}`);
    console.log(`  ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: ${this.analysis.framework || 'ãªã—'}`);
    console.log(`  ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼: ${this.analysis.packageManager || 'ä¸æ˜'}`);
    console.log(`  ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«: ${this.analysis.buildTool || 'ãªã—'}`);
    console.log(`  ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: ${this.analysis.testFramework || 'ãªã—'}`);
    console.log(`  Linter: ${this.analysis.linter || 'ãªã—'}`);
    console.log(`  Formatter: ${this.analysis.formatter || 'ãªã—'}`);

    if (this.analysis.git.hasRepo) {
      console.log('\nğŸ“ Gitæƒ…å ±:');
      console.log(`  ãƒ–ãƒ©ãƒ³ãƒ: ${this.analysis.git.currentBranch}`);
      console.log(`  å¤‰æ›´: ${this.analysis.git.hasChanges ? 'ã‚ã‚Š' : 'ãªã—'}`);
      console.log(`  ãƒªãƒ¢ãƒ¼ãƒˆ: ${this.analysis.git.remote || 'ãªã—'}`);
    }

    if (Object.keys(this.analysis.structure).length > 0) {
      console.log('\nğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ :');
      Object.entries(this.analysis.structure).forEach(([dir, contents]) => {
        console.log(`  ${dir}/`);
        if (contents && typeof contents === 'object') {
          Object.keys(contents).slice(0, 5).forEach(item => {
            console.log(`    â”œâ”€â”€ ${item}`);
          });
        }
      });
    }

    if (this.analysis.recommendations.length > 0) {
      console.log('\nğŸ’¡ æ¨å¥¨æ”¹å–„ç‚¹:');
      this.analysis.recommendations.forEach(rec => {
        console.log(`  ${rec}`);
      });
    }

    console.log('\nğŸ¯ åˆ©ç”¨å¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰:');
    console.log('  /quality-setup - å“è³ªãƒ„ãƒ¼ãƒ«ä¸€æ‹¬è¨­å®š');
    console.log('  /deps-update - ä¾å­˜é–¢ä¿‚ä¸€æ‹¬æ›´æ–°');
    console.log('  /github-setup - GitHub Actionsè¨­å®š');
    console.log('  /project-clean - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—');
    console.log('  /test-setup - ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—');
  }
}

if (require.main === module) {
  new ProjectAnalyzer().analyze();
}

module.exports = { ProjectAnalyzer };