import { CraftingEngineServiceLive, RecipeRegistryServiceLive } from '@domain/crafting/application_service'
import type {
  CraftingGrid as CraftingGridType,
  CraftingItemStack,
  CraftingRecipe,
} from '@domain/crafting/types'
import { GridHeight, GridWidth } from '@domain/crafting/types'
import { InventoryServiceLive } from '@domain/inventory/live'
import { ItemRegistry } from '@domain/inventory/ItemRegistry'
import { Effect, Layer, ManagedRuntime, Stream } from 'effect'
import React, { useCallback, useEffect, useRef, useState } from 'react'
import { CraftingGUIService, CraftingGUIServiceLive } from '../CraftingGUIService'
import type { CraftingGUIEvent, CraftingGUIState, CraftingResultDisplay, CraftingSession } from '../CraftingGUITypes'
import { CraftingGrid } from './CraftingGrid'
import { CraftingResult } from './CraftingResult'
import { RecipeBook } from './RecipeBook'

interface CraftingTableGUIProps {
  playerId: string
  tableType?: CraftingSession['craftingTableType']
  onClose?: () => void
  className?: string
}

// Create runtime with all required services
const createCraftingRuntime = () => {
  const MainLayer = Layer.mergeAll(
    ItemRegistry.Default,
    RecipeRegistryServiceLive,
    CraftingEngineServiceLive,
    InventoryServiceLive,
    CraftingGUIServiceLive
  )

  return ManagedRuntime.make(MainLayer as any)
}

export const CraftingTableGUI: React.FC<CraftingTableGUIProps> = ({
  playerId,
  tableType = 'workbench',
  onClose,
  className = '',
}) => {
  const [state, setState] = useState<CraftingGUIState>({
    _tag: 'CraftingGUIState',
    sessionId: '',
    craftingGrid: [
      [null, null, null],
      [null, null, null],
      [null, null, null],
    ],
    resultSlot: null,
    selectedRecipe: null,
    availableRecipes: [],
    isProcessing: false,
    isDragging: false,
    draggedItem: null,
    draggedFromSlot: null,
    hoveredSlot: null,
    searchQuery: '',
    selectedCategory: 'all',
    showRecipeBook: true,
    animations: {},
  })

  const [session, setSession] = useState<CraftingSession | null>(null)
  const [craftingResult, setCraftingResult] = useState<CraftingResultDisplay | null>(null)
  const [recipes, setRecipes] = useState<readonly CraftingRecipe[]>([])
  const [isInitialized, setIsInitialized] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const runtimeRef = useRef<ManagedRuntime.ManagedRuntime<any, any> | null>(null)
  const serviceRef = useRef<CraftingGUIService | null>(null)
  const updateStreamRef = useRef<any>(null)

  // Initialize the service
  useEffect(() => {
    const initService = async () => {
      try {
        const runtime = createCraftingRuntime()
        runtimeRef.current = runtime

        // Get the service from runtime - ManagedRuntime provides service access
        const serviceEffect = Effect.gen(function* () {
          return yield* CraftingGUIService
        })
        const service = await runtime.runPromise(serviceEffect)
        serviceRef.current = service

        // Initialize session
        const sessionEffect = service.initializeSession(playerId, tableType)
        const sessionResult = await runtime.runPromise(sessionEffect)
        setSession(sessionResult)

        // Get initial state
        const stateEffect = service.getState()
        const initialState = await runtime.runPromise(stateEffect)
        setState(initialState)

        // Load recipes
        const recipesEffect = service.getAvailableRecipes()
        const availableRecipes = await runtime.runPromise(recipesEffect)
        setRecipes(availableRecipes)

        // Subscribe to updates
        const updateStream = service.subscribeToUpdates()
        updateStreamRef.current = runtime.runFork(
          Stream.runForEach(updateStream, (newState: CraftingGUIState) => Effect.sync(() => setState(newState)))
        )

        setIsInitialized(true)
      } catch (err) {
        console.error('Failed to initialize crafting service:', err)
        setError('Failed to initialize crafting table')
      }
    }

    initService()

    return () => {
      // Cleanup
      if (updateStreamRef.current) {
        updateStreamRef.current.unsafeInterrupt()
      }
      if (serviceRef.current && runtimeRef.current) {
        const disposeEffect = serviceRef.current.dispose()
        runtimeRef.current.runPromise(disposeEffect)
      }
    }
  }, [playerId, tableType])

  // Event handlers
  const handleEvent = useCallback(async (event: CraftingGUIEvent) => {
    if (!serviceRef.current || !runtimeRef.current) return

    try {
      setState((prev) => ({ ...prev, isProcessing: true }))
      const effect = serviceRef.current.handleEvent(event)
      await runtimeRef.current.runPromise(effect)

      // Update crafting result if grid changed
      if (event._tag === 'ItemDrop' || event._tag === 'SlotClicked' || event._tag === 'GridCleared') {
        updateCraftingResult()
      }
    } catch (err) {
      console.error('Error handling event:', err)
      setError(`Failed to handle ${event._tag}`)
    } finally {
      setState((prev) => ({ ...prev, isProcessing: false }))
    }
  }, [])

  const updateCraftingResult = useCallback(async () => {
    if (!serviceRef.current || !runtimeRef.current) return

    try {
      const grid: CraftingGridType = {
        _tag: 'CraftingGrid',
        width: GridWidth(3),
        height: GridHeight(3),
        slots: state.craftingGrid as readonly (readonly (CraftingItemStack | null)[])[],
      }
      const effect = serviceRef.current.updateGrid(grid)
      const result = await runtimeRef.current.runPromise(effect)
      setCraftingResult(result)
    } catch (err) {
      console.error('Error updating crafting result:', err)
    }
  }, [state.craftingGrid])

  const handleCraft = useCallback(async () => {
    if (!serviceRef.current || !runtimeRef.current || !craftingResult?.canCraft) return

    try {
      setState((prev) => ({ ...prev, isProcessing: true }))

      // Trigger crafting animation
      setState((prev) => ({
        ...prev,
        animations: { ...prev.animations, crafting: true },
      }))

      const effect = serviceRef.current.craftItem(
        craftingResult.recipe ? (craftingResult.recipe as any).id : undefined,
        1
      )
      const result = await runtimeRef.current.runPromise(effect)

      // Show success animation
      setTimeout(() => {
        setState((prev) => ({
          ...prev,
          animations: { ...prev.animations, crafting: false },
        }))
      }, 500)

      // Update result display
      updateCraftingResult()
    } catch (err) {
      console.error('Error crafting item:', err)
      setError('Failed to craft item')
    } finally {
      setState((prev) => ({ ...prev, isProcessing: false }))
    }
  }, [craftingResult])

  const handleClearGrid = useCallback(() => {
    const event: CraftingGUIEvent = { _tag: 'GridCleared' }
    handleEvent(event)
  }, [handleEvent])

  const handleToggleRecipeBook = useCallback(() => {
    const event: CraftingGUIEvent = { _tag: 'RecipeBookToggled' }
    handleEvent(event)
  }, [handleEvent])

  const handleQuickCraft = useCallback(
    (recipeId: string, quantity: number) => {
      const event: CraftingGUIEvent = {
        _tag: 'CraftingRequested',
        recipeId,
        quantity,
      }
      handleEvent(event)
    },
    [handleEvent]
  )

  if (!isInitialized) {
    return (
      <div className="crafting-table-loading">
        <div className="loading-spinner">Loading crafting table...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="crafting-table-error">
        <div className="error-message">{error}</div>
        <button onClick={() => setError(null)}>Retry</button>
      </div>
    )
  }

  const gridProps = {
    _tag: 'CraftingGrid' as const,
    width: GridWidth(3),
    height: GridHeight(3),
    slots: state.craftingGrid as readonly (readonly (CraftingItemStack | null)[])[],
  }

  return (
    <div className={`crafting-table-gui ${className}`}>
      <div className="crafting-interface">
        {/* Main crafting area */}
        <div className="crafting-main">
          <div className="crafting-grid-container">
            <h3>Crafting Table</h3>
            <CraftingGrid
              grid={gridProps}
              onSlotClick={(event) => handleEvent(event)}
              onItemDragStart={(event) => handleEvent(event)}
              onItemDragEnd={(event) => handleEvent(event)}
              onItemDrop={(event) => handleEvent(event)}
            />
          </div>

          <div className="crafting-result-container">
            <CraftingResult
              result={craftingResult}
              onCraft={handleCraft}
              isProcessing={state.isProcessing}
              showAnimation={!!state.animations?.['crafting']}
            />
          </div>
        </div>

        {/* Recipe book sidebar */}
        {state.showRecipeBook && (
          <div className="recipe-book-container">
            <RecipeBook
              recipes={recipes}
              {...(state.selectedRecipe && { selectedRecipe: state.selectedRecipe })}
              filterConfig={{
                _tag: 'RecipeFilterConfig',
                categories: [state.selectedCategory],
                searchQuery: state.searchQuery,
                showCraftableOnly: true,
                sortBy: 'name',
                displayMode: 'grid',
              }}
              onRecipeSelect={(event: CraftingGUIEvent) => {
                handleEvent(event)
              }}
              onSearch={(event: CraftingGUIEvent) => {
                handleEvent(event)
              }}
              onCategoryChange={(event: CraftingGUIEvent) => {
                handleEvent(event)
              }}
              onQuickCraft={handleQuickCraft}
            />
          </div>
        )}
      </div>

      {/* Control buttons */}
      <div className="crafting-controls">
        <button onClick={handleToggleRecipeBook} className="toggle-recipe-book">
          {state.showRecipeBook ? 'Hide' : 'Show'} Recipe Book
        </button>
        <button onClick={handleClearGrid} className="clear-grid" disabled={state.isProcessing}>
          Clear Grid
        </button>
        {onClose && (
          <button onClick={onClose} className="close-crafting">
            Close
          </button>
        )}
      </div>

      {/* Session info */}
      {session && (
        <div className="session-info">
          <small>
            Session: {session.id} | Items crafted: {session.stats.itemsCrafted} | Recipes used:{' '}
            {session.stats.recipesUsed}
          </small>
        </div>
      )}
    </div>
  )
}
