import type { ItemId } from '@domain/item/types'
import { expect } from '@effect/vitest'
import { Duration, Effect, Either, Match, pipe, TestClock, TestContext } from 'effect'
import type { RecipeAggregate } from '../aggregate'
import type {
  CraftingDifficulty,
  CraftingTime,
  GridPosition,
  IngredientQuantity,
  RecipeId,
  SuccessRate,
} from '../value_object'

// ===================================
// Crafting Domain Test Helpers
// DDD準拠テスト支援ヘルパー群
// ===================================

// Recipe Aggregate Factory Helpers
export const createTestRecipeAggregate = (overrides: Partial<RecipeAggregate> = {}): RecipeAggregate => ({
  id: 'wooden-pickaxe' as RecipeId,
  type: 'shaped',
  pattern: [
    ['planks', 'planks', 'planks'],
    [null, 'stick', null],
    [null, 'stick', null],
  ],
  result: {
    itemId: 'wooden_pickaxe' as ItemId,
    quantity: 1 as IngredientQuantity,
  },
  requiredIngredients: new Map([
    ['planks' as ItemId, 3 as IngredientQuantity],
    ['stick' as ItemId, 2 as IngredientQuantity],
  ]),
  difficulty: 3 as CraftingDifficulty,
  craftingTime: 1000 as CraftingTime,
  successRate: 1.0 as SuccessRate,
  unlockedBy: [],
  category: 'tools',
  tags: new Set(['tool', 'pickaxe', 'wooden']),
  description: 'A basic wooden pickaxe for mining',
  ...overrides,
})

// ===================================
// Effect-TS Test Patterns
// ===================================

// DDD Aggregate 不変条件テスト
export const assertAggregateInvariants = <T>(
  aggregate: T,
  invariantChecks: Array<(agg: T) => boolean>,
  errorMessage: string = 'Aggregate invariant violation'
) =>
  Effect.gen(function* () {
    const allValid = invariantChecks.every((check) => check(aggregate))
    return allValid
      ? Effect.succeed(aggregate)
      : Effect.fail(new Error(`${errorMessage}: ${JSON.stringify(aggregate)}`))
  })

// Property-based テスト支援
export const assertPropertyHolds = <T>(value: T, property: (val: T) => boolean, propertyName: string) =>
  Effect.gen(function* () {
    return property(value)
      ? Effect.succeed(value)
      : Effect.fail(new Error(`Property '${propertyName}' failed for: ${JSON.stringify(value)}`))
  })

// DDD ビジネスルール検証
export const assertBusinessRule = <T>(input: T, rule: (val: T) => Either.Either<string, T>, ruleName: string) =>
  Effect.gen(function* () {
    const result = rule(input)
    return pipe(
      result,
      Either.match({
        onLeft: (error) => Effect.fail(new Error(`Business rule '${ruleName}' failed: ${error}`)),
        onRight: (success) => Effect.succeed(success),
      })
    )
  })

// Value Object 型安全性テスト
export const assertValueObjectValidation = <T, E>(factory: () => Either.Either<E, T>, expectedValue?: T) =>
  Effect.gen(function* () {
    const result = factory()
    return pipe(
      result,
      Either.match({
        onLeft: (error) => Effect.fail(error),
        onRight: (value) => {
          if (expectedValue) {
            expect(value).toEqual(expectedValue)
          }
          return Effect.succeed(value)
        },
      })
    )
  })

// 並行実行不変条件テスト
export const assertConcurrencyInvariant = <T>(
  operations: Array<Effect.Effect<T, any>>,
  invariantCheck: (results: T[]) => boolean,
  invariantName: string
) =>
  Effect.gen(function* () {
    const results = yield* Effect.all(operations, { concurrency: 'unbounded' })
    return invariantCheck(results)
      ? Effect.succeed(results)
      : Effect.fail(new Error(`Concurrency invariant '${invariantName}' violated`))
  })

// ===================================
// Specialized Crafting Assertions
// ===================================

// レシピ不変条件検証
export const assertRecipeInvariants = (recipe: RecipeAggregate) =>
  assertAggregateInvariants(
    recipe,
    [
      (r) => r.difficulty >= 1 && r.difficulty <= 10,
      (r) => r.craftingTime >= 10 && r.craftingTime <= 300000,
      (r) => r.successRate >= 0.0 && r.successRate <= 1.0,
      (r) => r.result.quantity >= 1 && r.result.quantity <= 64,
      (r) => r.requiredIngredients.size > 0,
    ],
    'Recipe aggregate invariants'
  )

// グリッド位置不変条件検証
export const assertGridPositionInvariants = (position: GridPosition) =>
  assertPropertyHolds(
    position,
    (pos) => {
      const { x, y } = pos
      return x >= 0 && x <= 2 && y >= 0 && y <= 2
    },
    'Grid position bounds'
  )

// 材料数量不変条件検証
export const assertIngredientQuantityInvariants = (quantity: IngredientQuantity) =>
  assertPropertyHolds(quantity, (q) => q >= 0 && q <= 64 && Number.isInteger(q), 'Ingredient quantity bounds and type')

// ===================================
// Test Runners for DDD Patterns
// ===================================

// DDD Aggregate Root テストランナー
export const runAggregateTest = <T, E>(effect: Effect.Effect<T, E>) =>
  pipe(effect, Effect.provide(TestContext.TestContext), Effect.runSync)

// DDD Domain Service テストランナー
export const runDomainServiceTest = <T, E>(effect: Effect.Effect<T, E>) =>
  pipe(effect, Effect.provide(TestContext.TestContext), Effect.runSync)

// 時間依存テスト用のランナー
export const runTimeBasedTest = <T, E>(effect: Effect.Effect<T, E>, timeAdvancement: Duration.Duration) =>
  pipe(
    Effect.gen(function* () {
      yield* TestClock.adjust(timeAdvancement)
      return yield* effect
    }),
    Effect.provide(TestContext.TestContext),
    Effect.runSync
  )

// ===================================
// Property-based Test Helpers
// ===================================

// レシピID生成器
export const generateRecipeId = (): RecipeId => {
  const ids = ['wooden-pickaxe', 'iron-sword', 'stone-axe', 'crafting-table', 'furnace', 'chest']
  return ids[Math.floor(Math.random() * ids.length)] as RecipeId
}

// 材料数量生成器
export const generateIngredientQuantity = (): IngredientQuantity => Math.floor(Math.random() * 65) as IngredientQuantity

// 難易度生成器
export const generateCraftingDifficulty = (): CraftingDifficulty =>
  (Math.floor(Math.random() * 10) + 1) as CraftingDifficulty

// 製作時間生成器（10ms - 300,000ms）
export const generateCraftingTime = (): CraftingTime => {
  const timeValues = [10, 100, 500, 1000, 2000, 5000, 30000, 60000, 300000]
  return timeValues[Math.floor(Math.random() * timeValues.length)] as CraftingTime
}

// 成功率生成器
export const generateSuccessRate = (): SuccessRate => parseFloat(Math.random().toFixed(2)) as SuccessRate

// グリッド位置生成器
export const generateGridPosition = (): GridPosition => ({
  x: Math.floor(Math.random() * 3) as 0 | 1 | 2,
  y: Math.floor(Math.random() * 3) as 0 | 1 | 2,
})

// ===================================
// Match.value パターン統合
// ===================================

// 難易度カテゴリマッチングヘルパー
export const matchDifficultyCategory = (difficulty: CraftingDifficulty) =>
  pipe(
    difficulty,
    Match.value,
    Match.when(
      (d) => d >= 1 && d <= 2,
      () => 'trivial'
    ),
    Match.when(
      (d) => d >= 3 && d <= 4,
      () => 'easy'
    ),
    Match.when(
      (d) => d >= 5 && d <= 6,
      () => 'normal'
    ),
    Match.when(
      (d) => d >= 7 && d <= 8,
      () => 'hard'
    ),
    Match.when(
      (d) => d >= 9 && d <= 10,
      () => 'legendary'
    ),
    Match.exhaustive
  )

// 成功率カテゴリマッチングヘルパー
export const matchSuccessRateCategory = (rate: SuccessRate) =>
  pipe(
    rate,
    Match.value,
    Match.when(
      (r) => r === 1.0,
      () => 'guaranteed'
    ),
    Match.when(
      (r) => r >= 0.9,
      () => 'very_high'
    ),
    Match.when(
      (r) => r >= 0.7,
      () => 'high'
    ),
    Match.when(
      (r) => r >= 0.5,
      () => 'medium'
    ),
    Match.when(
      (r) => r >= 0.3,
      () => 'low'
    ),
    Match.when(
      (r) => r < 0.3,
      () => 'very_low'
    ),
    Match.exhaustive
  )

// グリッド位置マッチングヘルパー
export const matchGridPositionCategory = (position: GridPosition) =>
  pipe(
    position,
    Match.value,
    Match.when(
      (p) => p.x === 1 && p.y === 1,
      () => 'center'
    ),
    Match.when(
      (p) => p.x === 0 || p.x === 2 || p.y === 0 || p.y === 2,
      () => 'edge'
    ),
    Match.when(
      (p) => (p.x === 0 || p.x === 2) && (p.y === 0 || p.y === 2),
      () => 'corner'
    ),
    Match.orElse(() => 'middle')
  )

// ===================================
// Performance Test Utilities
// ===================================

// 大量データ処理テスト
export const runBulkOperationTest = <T>(
  operation: () => Effect.Effect<T, any>,
  iterations: number,
  maxExecutionTime: number
) =>
  Effect.gen(function* () {
    const startTime = Date.now()
    const results = yield* Effect.all(Array.from({ length: iterations }, operation), { concurrency: 'unbounded' })
    const endTime = Date.now()
    const executionTime = endTime - startTime

    return executionTime <= maxExecutionTime
      ? Effect.succeed({ results, executionTime })
      : Effect.fail(new Error(`Bulk operation exceeded time limit: ${executionTime}ms > ${maxExecutionTime}ms`))
  })

// メモリ効率テスト
export const assertMemoryEfficiency = <T>(operation: () => Effect.Effect<T, any>, maxMemoryIncrease: number) =>
  Effect.gen(function* () {
    const initialMemory = process.memoryUsage().heapUsed
    const result = yield* operation()
    const finalMemory = process.memoryUsage().heapUsed
    const memoryIncrease = finalMemory - initialMemory

    return memoryIncrease <= maxMemoryIncrease
      ? Effect.succeed(result)
      : Effect.fail(new Error(`Memory usage exceeded limit: ${memoryIncrease} bytes > ${maxMemoryIncrease} bytes`))
  })

// パフォーマンステスト: 連続実行効率
export const assertOperationEfficiency = <T>(
  operation: () => Effect.Effect<T, any>,
  operationsPerSecond: number,
  testDuration: number = 1000
) =>
  Effect.gen(function* () {
    const operationCount = Math.floor((operationsPerSecond * testDuration) / 1000)
    const startTime = Date.now()

    const results = yield* Effect.all(Array.from({ length: operationCount }, operation), { concurrency: 'unbounded' })

    const endTime = Date.now()
    const actualDuration = endTime - startTime
    const actualOpsPerSec = (operationCount / actualDuration) * 1000

    return actualOpsPerSec >= operationsPerSecond
      ? Effect.succeed({ results, actualOpsPerSec, targetOpsPerSec: operationsPerSecond })
      : Effect.fail(
          new Error(
            `Operation efficiency below target: ${actualOpsPerSec.toFixed(2)} ops/sec < ${operationsPerSecond} ops/sec`
          )
        )
  })

// ===================================
// Minecraft-specific Test Helpers
// ===================================

// 3x3グリッドパターン検証
export const assertValidCraftingPattern = (pattern: (string | null)[][]) =>
  assertPropertyHolds(
    pattern,
    (p) => p.length === 3 && p.every((row) => row.length === 3),
    'Valid 3x3 crafting pattern'
  )

// レシピ材料検証
export const assertValidIngredients = (ingredients: Map<ItemId, IngredientQuantity>) =>
  assertPropertyHolds(
    ingredients,
    (ing) => ing.size > 0 && Array.from(ing.values()).every((q) => q >= 1 && q <= 64),
    'Valid recipe ingredients'
  )

// アイテムスタック制限検証
export const assertStackLimits = (quantity: IngredientQuantity, itemType: string) =>
  assertBusinessRule(
    { quantity, itemType },
    ({ quantity, itemType }) => {
      // Minecraftスタックルール
      const stackLimits: Record<string, number> = {
        default: 64,
        tool: 1,
        weapon: 1,
        armor: 1,
        bucket: 16,
        ender_pearl: 16,
        snowball: 16,
      }

      const maxStack = stackLimits[itemType] || stackLimits.default
      return quantity <= maxStack
        ? Either.right({ quantity, itemType })
        : Either.left(`Stack size ${quantity} exceeds limit ${maxStack} for ${itemType}`)
    },
    'Minecraft stack limits'
  )
