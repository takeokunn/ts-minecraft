import { describe, expect, it } from '@effect/vitest'
import { Effect, Either } from 'effect'
import * as RecipeAggregate from '../../aggregate/recipe'
import * as DifficultyVo from '../../value_object/crafting_difficulty'
import * as TimeVo from '../../value_object/crafting_time'
import * as GridPosVo from '../../value_object/grid_position'
import * as QuantityVo from '../../value_object/ingredient_quantity'
import * as RecipeIdVo from '../../value_object/recipe_id'
import * as SuccessRateVo from '../../value_object/success_rate'
import {
  assertBusinessRule,
  assertConcurrencyInvariant,
  assertPropertyHolds,
  assertRecipeInvariants,
  createTestRecipeAggregate,
} from '../crafting-test-helpers'

// ===================================
// Recipe Aggregate Tests
// レシピ集約のビジネスルールと不変条件
// ===================================

describe('Recipe Aggregate - DDD Business Rules Tests', () => {
  // ===================================
  // Aggregate Creation Tests
  // ===================================

  describe('Aggregate Creation', () => {
    it.effect('should create a valid recipe aggregate', () =>
      Effect.gen(function* () {
        const recipeId = yield* RecipeIdVo.create('wooden-pickaxe')
        const difficulty = yield* DifficultyVo.create(3)
        const craftingTime = yield* TimeVo.create(1000)
        const successRate = yield* SuccessRateVo.create(0.95)

        const recipe = yield* RecipeAggregate.createRecipeAggregate({
          id: recipeId,
          type: 'shaped',
          pattern: [
            ['planks', 'planks', 'planks'],
            [null, 'stick', null],
            [null, 'stick', null],
          ],
          result: {
            itemId: 'wooden_pickaxe' as any,
            quantity: yield* QuantityVo.create(1),
          },
          requiredIngredients: new Map([
            ['planks' as any, yield* QuantityVo.create(3)],
            ['stick' as any, yield* QuantityVo.create(2)],
          ]),
          difficulty,
          craftingTime,
          successRate,
          unlockedBy: [],
          category: 'tools',
          tags: new Set(['tool', 'pickaxe', 'wooden']),
          description: 'A basic wooden pickaxe for mining',
        })

        // 基本プロパティの確認
        expect(recipe.id).toBe(recipeId)
        expect(recipe.type).toBe('shaped')
        expect(recipe.category).toBe('tools')
        expect(recipe.description).toBe('A basic wooden pickaxe for mining')

        // 集約不変条件の確認
        yield* assertRecipeInvariants(recipe)

        yield* assertPropertyHolds(
          recipe,
          (r) => r.requiredIngredients.size > 0 && r.result.quantity >= 1,
          'Recipe aggregate creation invariants'
        )
      })
    )

    it.effect('should validate recipe structure on creation', () =>
      Effect.gen(function* () {
        const recipeId = yield* RecipeIdVo.create('invalid-recipe')

        // 不正なパターン（4x4グリッド）
        const invalidPatternResult = yield* Effect.either(
          RecipeAggregate.createRecipeAggregate({
            id: recipeId,
            type: 'shaped',
            pattern: [
              ['item1', 'item2', 'item3', 'item4'],
              ['item5', 'item6', 'item7', 'item8'],
              ['item9', 'item10', 'item11', 'item12'],
              ['item13', 'item14', 'item15', 'item16'],
            ] as any,
            result: {
              itemId: 'result' as any,
              quantity: yield* QuantityVo.create(1),
            },
            requiredIngredients: new Map(),
            difficulty: yield* DifficultyVo.create(5),
            craftingTime: yield* TimeVo.create(1000),
            successRate: yield* SuccessRateVo.create(1.0),
            unlockedBy: [],
            category: 'misc',
            tags: new Set(),
            description: 'Invalid recipe',
          })
        )

        expect(Either.isLeft(invalidPatternResult)).toBe(true)

        // 空の材料リスト
        const emptyIngredientsResult = yield* Effect.either(
          RecipeAggregate.createRecipeAggregate({
            id: recipeId,
            type: 'shaped',
            pattern: [
              ['item', null, null],
              [null, null, null],
              [null, null, null],
            ],
            result: {
              itemId: 'result' as any,
              quantity: yield* QuantityVo.create(1),
            },
            requiredIngredients: new Map(),
            difficulty: yield* DifficultyVo.create(5),
            craftingTime: yield* TimeVo.create(1000),
            successRate: yield* SuccessRateVo.create(1.0),
            unlockedBy: [],
            category: 'misc',
            tags: new Set(),
            description: 'Empty ingredients recipe',
          })
        )

        expect(Either.isLeft(emptyIngredientsResult)).toBe(true)

        yield* assertPropertyHolds(
          { invalidPattern: invalidPatternResult, emptyIngredients: emptyIngredientsResult },
          ({ invalidPattern, emptyIngredients }) => Either.isLeft(invalidPattern) && Either.isLeft(emptyIngredients),
          'Recipe structure validation'
        )
      })
    )

    it.effect('should create shapeless recipes correctly', () =>
      Effect.gen(function* () {
        const recipeId = yield* RecipeIdVo.create('bread')

        const shapelessRecipe = yield* RecipeAggregate.createRecipeAggregate({
          id: recipeId,
          type: 'shapeless',
          ingredients: [{ itemId: 'wheat' as any, quantity: yield* QuantityVo.create(3) }],
          result: {
            itemId: 'bread' as any,
            quantity: yield* QuantityVo.create(1),
          },
          requiredIngredients: new Map([['wheat' as any, yield* QuantityVo.create(3)]]),
          difficulty: yield* DifficultyVo.create(2),
          craftingTime: yield* TimeVo.create(500),
          successRate: yield* SuccessRateVo.create(1.0),
          unlockedBy: [],
          category: 'food',
          tags: new Set(['food', 'basic']),
          description: 'Basic bread made from wheat',
        })

        expect(shapelessRecipe.type).toBe('shapeless')
        expect(shapelessRecipe.category).toBe('food')

        yield* assertRecipeInvariants(shapelessRecipe)

        yield* assertPropertyHolds(
          shapelessRecipe,
          (r) => r.type === 'shapeless' && r.requiredIngredients.has('wheat' as any),
          'Shapeless recipe creation'
        )
      })
    )
  })

  // ===================================
  // Pattern Matching Tests
  // ===================================

  describe('Pattern Matching', () => {
    it.effect('should validate shaped recipe patterns correctly', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate({
          type: 'shaped',
          pattern: [
            ['stick', null, null],
            ['stick', null, null],
            ['planks', null, null],
          ],
        })

        const validGrid = [
          ['stick', null, null],
          ['stick', null, null],
          ['planks', null, null],
        ]

        const invalidGrid = [
          ['planks', null, null],
          ['stick', null, null],
          ['stick', null, null],
        ]

        const isValidMatch = RecipeAggregate.matchShapedPattern(recipe, validGrid)
        const isInvalidMatch = RecipeAggregate.matchShapedPattern(recipe, invalidGrid)

        expect(isValidMatch).toBe(true)
        expect(isInvalidMatch).toBe(false)

        yield* assertPropertyHolds(
          { isValidMatch, isInvalidMatch },
          ({ isValidMatch, isInvalidMatch }) => isValidMatch && !isInvalidMatch,
          'Shaped pattern matching'
        )
      })
    )

    it.effect('should validate shapeless recipe patterns correctly', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate({
          type: 'shapeless',
          ingredients: [{ itemId: 'wheat' as any, quantity: QuantityVo.unsafe(3) }],
        })

        const validItems = [
          { itemId: 'wheat', quantity: 3 },
          { itemId: 'wheat', quantity: 1 },
          { itemId: 'wheat', quantity: 2 },
        ]

        const invalidItems = [{ itemId: 'wheat', quantity: 2 }]

        const isValidMatch = RecipeAggregate.matchShapelessPattern(recipe, validItems as any)
        const isInvalidMatch = RecipeAggregate.matchShapelessPattern(recipe, invalidItems as any)

        expect(isValidMatch).toBe(true)
        expect(isInvalidMatch).toBe(false)

        yield* assertPropertyHolds(
          { isValidMatch, isInvalidMatch },
          ({ isValidMatch, isInvalidMatch }) => isValidMatch && !isInvalidMatch,
          'Shapeless pattern matching'
        )
      })
    )

    it.effect('should check pattern matching at specific positions', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate({
          type: 'shaped',
          pattern: [
            ['planks', 'planks', 'planks'],
            [null, 'stick', null],
            [null, 'stick', null],
          ],
        })

        const grid = [
          ['planks', 'planks', 'planks'],
          [null, 'stick', null],
          [null, 'stick', null],
        ]

        // 各位置でのマッチング確認
        const position = yield* GridPosVo.create(1, 1) // 中央位置
        const isMatchAtPosition = RecipeAggregate.checkPatternAt(recipe, grid, position)

        expect(isMatchAtPosition).toBe(true)

        yield* assertPropertyHolds(
          { isMatchAtPosition },
          ({ isMatchAtPosition }) => isMatchAtPosition,
          'Pattern matching at specific position'
        )
      })
    )
  })

  // ===================================
  // Grid Compatibility Tests
  // ===================================

  describe('Grid Compatibility', () => {
    it.effect('should check if recipe can be crafted with given grid', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        const craftableGrid = [
          ['planks', 'planks', 'planks'],
          [null, 'stick', null],
          [null, 'stick', null],
        ]

        const uncraftableGrid = [
          ['stone', 'stone', 'stone'],
          [null, 'stick', null],
          [null, 'stick', null],
        ]

        const canCraft = RecipeAggregate.canCraftWithGrid(recipe, craftableGrid)
        const cannotCraft = RecipeAggregate.canCraftWithGrid(recipe, uncraftableGrid)

        expect(canCraft).toBe(true)
        expect(cannotCraft).toBe(false)

        yield* assertPropertyHolds(
          { canCraft, cannotCraft },
          ({ canCraft, cannotCraft }) => canCraft && !cannotCraft,
          'Grid compatibility checking'
        )
      })
    )

    it.effect('should match items correctly', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        const matchingItem = 'planks'
        const nonMatchingItem = 'stone'
        const nullItem = null

        const matchesPlank = RecipeAggregate.matchesItem(recipe, matchingItem, 'planks')
        const doesNotMatchStone = RecipeAggregate.matchesItem(recipe, nonMatchingItem, 'planks')
        const matchesNull = RecipeAggregate.matchesItem(recipe, nullItem, null)

        expect(matchesPlank).toBe(true)
        expect(doesNotMatchStone).toBe(false)
        expect(matchesNull).toBe(true)

        yield* assertPropertyHolds(
          { matchesPlank, doesNotMatchStone, matchesNull },
          ({ matchesPlank, doesNotMatchStone, matchesNull }) => matchesPlank && !doesNotMatchStone && matchesNull,
          'Item matching logic'
        )
      })
    )
  })

  // ===================================
  // Recipe Modification Tests
  // ===================================

  describe('Recipe Modification', () => {
    it.effect('should update recipe properties correctly', () =>
      Effect.gen(function* () {
        const originalRecipe = createTestRecipeAggregate()

        // 難易度の更新
        const newDifficulty = yield* DifficultyVo.create(8)
        const updatedDifficulty = RecipeAggregate.updateDifficulty(originalRecipe, newDifficulty)

        expect(updatedDifficulty.difficulty).toBe(newDifficulty)
        expect(updatedDifficulty.id).toBe(originalRecipe.id) // 他のプロパティは変更されない

        // 製作時間の更新
        const newTime = yield* TimeVo.create(2000)
        const updatedTime = RecipeAggregate.updateCraftingTime(originalRecipe, newTime)

        expect(updatedTime.craftingTime).toBe(newTime)

        // 成功率の更新
        const newSuccessRate = yield* SuccessRateVo.create(0.8)
        const updatedSuccessRate = RecipeAggregate.updateSuccessRate(originalRecipe, newSuccessRate)

        expect(updatedSuccessRate.successRate).toBe(newSuccessRate)

        // 説明の更新
        const newDescription = 'Updated description'
        const updatedDescription = RecipeAggregate.updateDescription(originalRecipe, newDescription)

        expect(updatedDescription.description).toBe(newDescription)

        yield* assertPropertyHolds(
          { updatedDifficulty, updatedTime, updatedSuccessRate, updatedDescription },
          ({ updatedDifficulty, updatedTime, updatedSuccessRate, updatedDescription }) =>
            DifficultyVo.toNumber(updatedDifficulty.difficulty) === 8 &&
            TimeVo.toMilliseconds(updatedTime.craftingTime) === 2000 &&
            SuccessRateVo.toNumber(updatedSuccessRate.successRate) === 0.8 &&
            updatedDescription.description === newDescription,
          'Recipe property updates'
        )
      })
    )

    it.effect('should manage recipe tags correctly', () =>
      Effect.gen(function* () {
        const originalRecipe = createTestRecipeAggregate({
          tags: new Set(['tool', 'pickaxe']),
        })

        // タグの追加
        const withNewTag = RecipeAggregate.addTag(originalRecipe, 'wooden')
        expect(withNewTag.tags.has('wooden')).toBe(true)
        expect(withNewTag.tags.has('tool')).toBe(true) // 既存のタグも保持

        // タグの削除
        const withoutPickaxeTag = RecipeAggregate.removeTag(withNewTag, 'pickaxe')
        expect(withoutPickaxeTag.tags.has('pickaxe')).toBe(false)
        expect(withoutPickaxeTag.tags.has('tool')).toBe(true) // 他のタグは残る

        yield* assertPropertyHolds(
          { withNewTag, withoutPickaxeTag },
          ({ withNewTag, withoutPickaxeTag }) =>
            withNewTag.tags.has('wooden') &&
            !withoutPickaxeTag.tags.has('pickaxe') &&
            withoutPickaxeTag.tags.has('tool'),
          'Tag management operations'
        )
      })
    )

    it.effect('should clone recipe aggregate correctly', () =>
      Effect.gen(function* () {
        const originalRecipe = createTestRecipeAggregate()

        const clonedRecipe = RecipeAggregate.cloneRecipeAggregate(originalRecipe)

        // 基本プロパティの確認
        expect(clonedRecipe.id).toBe(originalRecipe.id)
        expect(clonedRecipe.type).toBe(originalRecipe.type)
        expect(clonedRecipe.category).toBe(originalRecipe.category)
        expect(clonedRecipe.description).toBe(originalRecipe.description)

        // 深いコピーの確認（参照が異なる）
        expect(clonedRecipe).not.toBe(originalRecipe)
        expect(clonedRecipe.tags).not.toBe(originalRecipe.tags)
        expect(clonedRecipe.requiredIngredients).not.toBe(originalRecipe.requiredIngredients)

        // 内容は同じ
        expect(clonedRecipe.tags.size).toBe(originalRecipe.tags.size)
        expect(clonedRecipe.requiredIngredients.size).toBe(originalRecipe.requiredIngredients.size)

        yield* assertPropertyHolds(
          { originalRecipe, clonedRecipe },
          ({ originalRecipe, clonedRecipe }) =>
            clonedRecipe.id === originalRecipe.id && clonedRecipe !== originalRecipe, // 異なるオブジェクト
          'Recipe cloning operation'
        )
      })
    )
  })

  // ===================================
  // Recipe Validation Tests
  // ===================================

  describe('Recipe Validation', () => {
    it.effect('should validate recipe structure comprehensively', () =>
      Effect.gen(function* () {
        const validRecipe = createTestRecipeAggregate()
        const validationResult = yield* RecipeAggregate.validateRecipe(validRecipe)

        expect(Either.isRight(validationResult)).toBe(true)

        yield* assertPropertyHolds(validationResult, (result) => Either.isRight(result), 'Valid recipe validation')
      })
    )

    it.effect('should detect invalid recipe structures', () =>
      Effect.gen(function* () {
        // 不正な材料数量を持つレシピ
        const invalidQuantityRecipe = createTestRecipeAggregate({
          requiredIngredients: new Map([
            ['planks' as any, QuantityVo.unsafe(0)], // 無効な数量
          ]),
        })

        const validationResult = yield* Effect.either(RecipeAggregate.validateRecipe(invalidQuantityRecipe))

        expect(Either.isLeft(validationResult)).toBe(true)

        yield* assertPropertyHolds(
          validationResult,
          (result) => Either.isLeft(result),
          'Invalid recipe structure detection'
        )
      })
    )

    it.effect('should validate shaped recipes specifically', () =>
      Effect.gen(function* () {
        const shapedRecipe = createTestRecipeAggregate({
          type: 'shaped',
          pattern: [
            ['planks', 'planks', 'planks'],
            [null, 'stick', null],
            [null, 'stick', null],
          ],
        })

        const validationResult = yield* RecipeAggregate.validateShapedRecipe(shapedRecipe)

        expect(Either.isRight(validationResult)).toBe(true)

        yield* assertPropertyHolds(validationResult, (result) => Either.isRight(result), 'Shaped recipe validation')
      })
    )

    it.effect('should validate shapeless recipes specifically', () =>
      Effect.gen(function* () {
        const shapelessRecipe = createTestRecipeAggregate({
          type: 'shapeless',
          ingredients: [{ itemId: 'wheat' as any, quantity: QuantityVo.unsafe(3) }],
        })

        const validationResult = yield* RecipeAggregate.validateShapelessRecipe(shapelessRecipe)

        expect(Either.isRight(validationResult)).toBe(true)

        yield* assertPropertyHolds(validationResult, (result) => Either.isRight(result), 'Shapeless recipe validation')
      })
    )

    it.effect('should validate recipe structure invariants', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        const structureValidation = yield* RecipeAggregate.validateRecipeStructure(recipe)

        expect(Either.isRight(structureValidation)).toBe(true)

        yield* assertPropertyHolds(
          structureValidation,
          (result) => Either.isRight(result),
          'Recipe structure invariants'
        )
      })
    )
  })

  // ===================================
  // Business Rule Tests
  // ===================================

  describe('Business Rules', () => {
    it.effect('should enforce minimum ingredient requirements', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        yield* assertBusinessRule(
          recipe,
          (r) =>
            r.requiredIngredients.size > 0 ? Either.right(r) : Either.left('Recipe must have at least one ingredient'),
          'Minimum ingredient requirement'
        )
      })
    )

    it.effect('should enforce valid difficulty ranges', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        yield* assertBusinessRule(
          recipe,
          (r) => {
            const difficulty = DifficultyVo.toNumber(r.difficulty)
            return difficulty >= 1 && difficulty <= 10
              ? Either.right(r)
              : Either.left('Difficulty must be between 1 and 10')
          },
          'Valid difficulty range'
        )
      })
    )

    it.effect('should enforce valid success rate ranges', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        yield* assertBusinessRule(
          recipe,
          (r) => {
            const successRate = SuccessRateVo.toNumber(r.successRate)
            return successRate >= 0.0 && successRate <= 1.0
              ? Either.right(r)
              : Either.left('Success rate must be between 0.0 and 1.0')
          },
          'Valid success rate range'
        )
      })
    )

    it.effect('should enforce valid crafting time ranges', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        yield* assertBusinessRule(
          recipe,
          (r) => {
            const time = TimeVo.toMilliseconds(r.craftingTime)
            return time >= 10 && time <= 300000
              ? Either.right(r)
              : Either.left('Crafting time must be between 10ms and 300s')
          },
          'Valid crafting time range'
        )
      })
    )

    it.effect('should enforce valid result quantities', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        yield* assertBusinessRule(
          recipe,
          (r) => {
            const quantity = QuantityVo.toNumber(r.result.quantity)
            return quantity >= 1 && quantity <= 64
              ? Either.right(r)
              : Either.left('Result quantity must be between 1 and 64')
          },
          'Valid result quantity range'
        )
      })
    )
  })

  // ===================================
  // Aggregate Invariants Tests
  // ===================================

  describe('Aggregate Invariants', () => {
    it.effect('should maintain invariants through modifications', () =>
      Effect.gen(function* () {
        const originalRecipe = createTestRecipeAggregate()

        // 各種修正操作を行う
        const newDifficulty = yield* DifficultyVo.create(7)
        const modifiedRecipe = RecipeAggregate.updateDifficulty(originalRecipe, newDifficulty)

        const withNewTag = RecipeAggregate.addTag(modifiedRecipe, 'enhanced')
        const finalRecipe = RecipeAggregate.removeTag(withNewTag, 'wooden')

        // 最終的なレシピでも不変条件が維持されていることを確認
        yield* assertRecipeInvariants(finalRecipe)

        yield* assertPropertyHolds(
          finalRecipe,
          (recipe) =>
            DifficultyVo.toNumber(recipe.difficulty) >= 1 &&
            DifficultyVo.toNumber(recipe.difficulty) <= 10 &&
            recipe.requiredIngredients.size > 0 &&
            QuantityVo.toNumber(recipe.result.quantity) >= 1,
          'Invariants maintained through modifications'
        )
      })
    )

    it.effect('should maintain pattern consistency', () =>
      Effect.gen(function* () {
        const shapedRecipe = createTestRecipeAggregate({
          type: 'shaped',
          pattern: [
            ['planks', 'planks', 'planks'],
            [null, 'stick', null],
            [null, 'stick', null],
          ],
        })

        yield* assertPropertyHolds(
          shapedRecipe,
          (recipe) => {
            if (recipe.type === 'shaped' && recipe.pattern) {
              return recipe.pattern.length === 3 && recipe.pattern.every((row) => row.length === 3)
            }
            return true
          },
          'Pattern consistency for shaped recipes'
        )
      })
    )

    it.effect('should maintain ingredient consistency', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        yield* assertPropertyHolds(
          recipe,
          (r) => {
            // 材料マップの全ての値が有効な数量であることを確認
            const allQuantitiesValid = Array.from(r.requiredIngredients.values()).every(
              (quantity) => QuantityVo.toNumber(quantity) >= 1 && QuantityVo.toNumber(quantity) <= 64
            )

            return allQuantitiesValid
          },
          'Ingredient quantity consistency'
        )
      })
    )
  })

  // ===================================
  // Property-based Tests
  // ===================================

  describe('Property-based Tests', () => {
    it.effect('should maintain recipe identity through operations', () =>
      Effect.gen(function* () {
        // レシピのIDは操作を通じて変更されないことを確認
        for (let i = 0; i < 20; i++) {
          const recipe = createTestRecipeAggregate({
            id: RecipeIdVo.unsafe(`test-recipe-${i}`),
          })

          const originalId = recipe.id

          // 様々な操作を実行
          const modified1 = RecipeAggregate.addTag(recipe, 'test-tag')
          const modified2 = RecipeAggregate.removeTag(modified1, 'wooden')
          const modified3 = RecipeAggregate.updateDescription(modified2, 'New description')

          yield* assertPropertyHolds(
            { originalId, finalId: modified3.id },
            ({ originalId, finalId }) => originalId === finalId,
            `Recipe identity preservation: ${RecipeIdVo.toString(originalId)}`
          )
        }
      })
    )

    it.effect('should maintain tag set properties', () =>
      Effect.gen(function* () {
        for (let i = 0; i < 10; i++) {
          const recipe = createTestRecipeAggregate({
            tags: new Set(['initial', 'tag']),
          })

          // タグの追加と削除
          const withTag = RecipeAggregate.addTag(recipe, 'new-tag')
          const withoutTag = RecipeAggregate.removeTag(withTag, 'initial')

          yield* assertPropertyHolds(
            { withTag, withoutTag },
            ({ withTag, withoutTag }) =>
              withTag.tags.has('new-tag') &&
              withTag.tags.has('initial') &&
              !withoutTag.tags.has('initial') &&
              withoutTag.tags.has('new-tag'),
            `Tag set operations: iteration ${i}`
          )
        }
      })
    )

    it.effect('should maintain cloning properties', () =>
      Effect.gen(function* () {
        for (let i = 0; i < 15; i++) {
          const original = createTestRecipeAggregate({
            id: RecipeIdVo.unsafe(`clone-test-${i}`),
            description: `Test recipe ${i}`,
          })

          const cloned = RecipeAggregate.cloneRecipeAggregate(original)

          yield* assertPropertyHolds(
            { original, cloned },
            ({ original, cloned }) =>
              original.id === cloned.id &&
              original.description === cloned.description &&
              original !== cloned && // 異なるオブジェクト
              original.tags !== cloned.tags, // 異なるSetオブジェクト
            `Cloning properties: iteration ${i}`
          )
        }
      })
    )
  })

  // ===================================
  // Concurrency Tests
  // ===================================

  describe('Concurrency Tests', () => {
    it.effect('should handle concurrent recipe modifications safely', () =>
      Effect.gen(function* () {
        const baseRecipe = createTestRecipeAggregate()

        const concurrentModifications = Array.from({ length: 50 }, (_, i) =>
          Effect.sync(() => {
            const tag = `tag-${i}`
            const withTag = RecipeAggregate.addTag(baseRecipe, tag)
            const withDescription = RecipeAggregate.updateDescription(withTag, `Description ${i}`)
            return withDescription
          })
        )

        // 並行実行不変条件: 全ての変更が安全に実行される
        yield* assertConcurrencyInvariant(
          concurrentModifications,
          (results) =>
            results.every(
              (recipe, index) =>
                recipe.tags.has(`tag-${index}`) &&
                recipe.description === `Description ${index}` &&
                recipe.id === baseRecipe.id
            ),
          'Concurrent recipe modification safety'
        )
      })
    )

    it.effect('should maintain validation consistency under concurrency', () =>
      Effect.gen(function* () {
        const recipes = Array.from({ length: 30 }, (_, i) =>
          createTestRecipeAggregate({
            id: RecipeIdVo.unsafe(`concurrent-test-${i}`),
          })
        )

        const concurrentValidations = recipes.map((recipe) =>
          Effect.sync(() => RecipeAggregate.validateRecipeStructure(recipe))
        )

        const results = yield* Effect.all(concurrentValidations, { concurrency: 'unbounded' })

        yield* assertPropertyHolds(
          results,
          (resultArray) => resultArray.every((result) => Either.isRight(Effect.runSync(result))),
          'Concurrent validation consistency'
        )
      })
    )
  })

  // ===================================
  // Edge Cases and Error Handling
  // ===================================

  describe('Edge Cases', () => {
    it.effect('should handle edge case patterns correctly', () =>
      Effect.gen(function* () {
        // 全てnullのパターン
        const emptyPatternRecipe = createTestRecipeAggregate({
          type: 'shaped',
          pattern: [
            [null, null, null],
            [null, null, null],
            [null, null, null],
          ],
        })

        const emptyGrid = [
          [null, null, null],
          [null, null, null],
          [null, null, null],
        ]

        const matchesEmpty = RecipeAggregate.matchShapedPattern(emptyPatternRecipe, emptyGrid)
        expect(matchesEmpty).toBe(true)

        // 単一アイテムのパターン
        const singleItemPattern = createTestRecipeAggregate({
          type: 'shaped',
          pattern: [
            [null, null, null],
            [null, 'stick', null],
            [null, null, null],
          ],
        })

        const singleItemGrid = [
          [null, null, null],
          [null, 'stick', null],
          [null, null, null],
        ]

        const matchesSingle = RecipeAggregate.matchShapedPattern(singleItemPattern, singleItemGrid)
        expect(matchesSingle).toBe(true)

        yield* assertPropertyHolds(
          { matchesEmpty, matchesSingle },
          ({ matchesEmpty, matchesSingle }) => matchesEmpty && matchesSingle,
          'Edge case pattern matching'
        )
      })
    )

    it.effect('should handle boundary value modifications', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate()

        // 最小難易度
        const minDifficulty = yield* DifficultyVo.create(1)
        const withMinDifficulty = RecipeAggregate.updateDifficulty(recipe, minDifficulty)

        // 最大難易度
        const maxDifficulty = yield* DifficultyVo.create(10)
        const withMaxDifficulty = RecipeAggregate.updateDifficulty(recipe, maxDifficulty)

        // 最小時間
        const minTime = yield* TimeVo.create(10)
        const withMinTime = RecipeAggregate.updateCraftingTime(recipe, minTime)

        // 最大時間
        const maxTime = yield* TimeVo.create(300000)
        const withMaxTime = RecipeAggregate.updateCraftingTime(recipe, maxTime)

        yield* assertPropertyHolds(
          { withMinDifficulty, withMaxDifficulty, withMinTime, withMaxTime },
          ({ withMinDifficulty, withMaxDifficulty, withMinTime, withMaxTime }) =>
            DifficultyVo.toNumber(withMinDifficulty.difficulty) === 1 &&
            DifficultyVo.toNumber(withMaxDifficulty.difficulty) === 10 &&
            TimeVo.toMilliseconds(withMinTime.craftingTime) === 10 &&
            TimeVo.toMilliseconds(withMaxTime.craftingTime) === 300000,
          'Boundary value modifications'
        )
      })
    )

    it.effect('should handle complex tag operations', () =>
      Effect.gen(function* () {
        const recipe = createTestRecipeAggregate({
          tags: new Set(),
        })

        // 大量のタグを追加
        let withManyTags = recipe
        const tagNames = Array.from({ length: 100 }, (_, i) => `tag-${i}`)

        for (const tagName of tagNames) {
          withManyTags = RecipeAggregate.addTag(withManyTags, tagName)
        }

        expect(withManyTags.tags.size).toBe(100)

        // 半分のタグを削除
        let withFewerTags = withManyTags
        for (let i = 0; i < 50; i++) {
          withFewerTags = RecipeAggregate.removeTag(withFewerTags, `tag-${i}`)
        }

        expect(withFewerTags.tags.size).toBe(50)

        yield* assertPropertyHolds(
          { withManyTags, withFewerTags },
          ({ withManyTags, withFewerTags }) => withManyTags.tags.size === 100 && withFewerTags.tags.size === 50,
          'Complex tag operations'
        )
      })
    )
  })

  // ===================================
  // Performance Tests
  // ===================================

  describe('Performance Tests', () => {
    it.effect('should handle high-volume recipe operations efficiently', () =>
      Effect.gen(function* () {
        const operationCount = 1000
        const maxExecutionTime = 200 // 200ms for 1000 operations

        const bulkOperations = Array.from({ length: operationCount }, (_, i) =>
          Effect.sync(() => {
            const recipe = createTestRecipeAggregate({
              id: RecipeIdVo.unsafe(`perf-test-${i}`),
            })

            const withTag = RecipeAggregate.addTag(recipe, `perf-tag-${i}`)
            const withDifficulty = RecipeAggregate.updateDifficulty(withTag, DifficultyVo.unsafe((i % 10) + 1))
            const cloned = RecipeAggregate.cloneRecipeAggregate(withDifficulty)

            return {
              original: recipe,
              modified: withDifficulty,
              cloned,
              isValid: Effect.runSync(Effect.either(RecipeAggregate.validateRecipe(cloned))),
            }
          })
        )

        const startTime = Date.now()
        const results = yield* Effect.all(bulkOperations, { concurrency: 'unbounded' })
        const endTime = Date.now()
        const executionTime = endTime - startTime

        expect(executionTime).toBeLessThan(maxExecutionTime)
        expect(results.length).toBe(operationCount)

        yield* assertPropertyHolds(
          { results, executionTime, maxTime: maxExecutionTime },
          ({ results, executionTime, maxTime }) =>
            results.length === operationCount &&
            executionTime < maxTime &&
            results.every((result) => Either.isRight(result.isValid)),
          'High-volume operation performance'
        )
      })
    )
  })
})
