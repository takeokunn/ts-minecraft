import { describe, expect, it } from '@effect/vitest'
import { Effect, Either } from 'effect'
import * as RecipeValidationService from '../../domain_service/recipe_validation'
import * as DifficultyVo from '../../value_object/crafting_difficulty'
import * as TimeVo from '../../value_object/crafting_time'
import * as QuantityVo from '../../value_object/ingredient_quantity'
import * as RecipeIdVo from '../../value_object/recipe_id'
import * as SuccessRateVo from '../../value_object/success_rate'
import {
  assertBusinessRule,
  assertConcurrencyInvariant,
  assertPropertyHolds,
  createTestRecipeAggregate,
} from '../crafting-test-helpers'

// ===================================
// Recipe Validation Domain Service Tests
// レシピ検証ドメインサービスのテスト
// ===================================

describe('Recipe Validation Domain Service Tests', () => {
  // ===================================
  // Service Layer Tests
  // ===================================

  describe('Service Layer Integration', () => {
    it.effect('should provide validation service correctly', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        expect(validationService).toBeDefined()
        expect(typeof validationService.validateRecipe).toBe('function')
        expect(typeof validationService.validateRecipeStructure).toBe('function')
        expect(typeof validationService.validateIngredients).toBe('function')
        expect(typeof validationService.validatePattern).toBe('function')

        yield* assertPropertyHolds(
          validationService,
          (service) =>
            typeof service.validateRecipe === 'function' &&
            typeof service.validateRecipeStructure === 'function' &&
            typeof service.validateIngredients === 'function' &&
            typeof service.validatePattern === 'function',
          'Service interface completeness'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )
  })

  // ===================================
  // Recipe Validation Tests
  // ===================================

  describe('Recipe Validation', () => {
    it.effect('should validate correct recipes successfully', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const validRecipe = createTestRecipeAggregate({
          id: yield* RecipeIdVo.create('wooden-sword'),
          type: 'shaped',
          pattern: [
            [null, 'planks', null],
            [null, 'planks', null],
            [null, 'stick', null],
          ],
          result: {
            itemId: 'wooden_sword' as any,
            quantity: yield* QuantityVo.create(1),
          },
          requiredIngredients: new Map([
            ['planks' as any, yield* QuantityVo.create(2)],
            ['stick' as any, yield* QuantityVo.create(1)],
          ]),
          difficulty: yield* DifficultyVo.create(2),
          craftingTime: yield* TimeVo.create(800),
          successRate: yield* SuccessRateVo.create(0.98),
        })

        const validationResult = yield* validationService.validateRecipe(validRecipe)

        expect(Either.isRight(validationResult)).toBe(true)
        if (Either.isRight(validationResult)) {
          expect(validationResult.right).toBe(validRecipe)
        }

        yield* assertPropertyHolds(
          validationResult,
          (result) => Either.isRight(result),
          'Valid recipe validation success'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should reject recipes with invalid structures', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        // 空の材料マップを持つ無効なレシピ
        const invalidRecipe = createTestRecipeAggregate({
          requiredIngredients: new Map(),
        })

        const validationResult = yield* validationService.validateRecipe(invalidRecipe)

        expect(Either.isLeft(validationResult)).toBe(true)
        if (Either.isLeft(validationResult)) {
          expect(validationResult.left.message).toContain('ingredients')
        }

        yield* assertPropertyHolds(
          validationResult,
          (result) => Either.isLeft(result),
          'Invalid recipe validation failure'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should validate recipe with complex patterns', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const complexRecipe = createTestRecipeAggregate({
          id: yield* RecipeIdVo.create('iron-chestplate'),
          type: 'shaped',
          pattern: [
            ['iron', null, 'iron'],
            ['iron', 'iron', 'iron'],
            ['iron', 'iron', 'iron'],
          ],
          requiredIngredients: new Map([['iron' as any, yield* QuantityVo.create(8)]]),
          difficulty: yield* DifficultyVo.create(6),
          craftingTime: yield* TimeVo.create(3000),
          successRate: yield* SuccessRateVo.create(0.85),
        })

        const validationResult = yield* validationService.validateRecipe(complexRecipe)

        expect(Either.isRight(validationResult)).toBe(true)

        yield* assertPropertyHolds(
          validationResult,
          (result) => Either.isRight(result),
          'Complex pattern recipe validation'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )
  })

  // ===================================
  // Recipe Structure Validation Tests
  // ===================================

  describe('Recipe Structure Validation', () => {
    it.effect('should validate recipe structure components', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const validRecipe = createTestRecipeAggregate()

        const structureValidation = yield* validationService.validateRecipeStructure(validRecipe)

        expect(Either.isRight(structureValidation)).toBe(true)

        yield* assertPropertyHolds(
          structureValidation,
          (result) => Either.isRight(result),
          'Valid recipe structure validation'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should detect invalid difficulty values', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const invalidDifficultyRecipe = createTestRecipeAggregate({
          difficulty: DifficultyVo.unsafe(15), // 無効な難易度
        })

        const structureValidation = yield* validationService.validateRecipeStructure(invalidDifficultyRecipe)

        expect(Either.isLeft(structureValidation)).toBe(true)

        yield* assertPropertyHolds(
          structureValidation,
          (result) => Either.isLeft(result),
          'Invalid difficulty detection'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should detect invalid success rates', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const invalidSuccessRateRecipe = createTestRecipeAggregate({
          successRate: SuccessRateVo.unsafe(1.5), // 無効な成功率
        })

        const structureValidation = yield* validationService.validateRecipeStructure(invalidSuccessRateRecipe)

        expect(Either.isLeft(structureValidation)).toBe(true)

        yield* assertPropertyHolds(
          structureValidation,
          (result) => Either.isLeft(result),
          'Invalid success rate detection'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should detect invalid crafting times', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const invalidTimeRecipe = createTestRecipeAggregate({
          craftingTime: TimeVo.unsafe(5), // 無効な時間（最小値未満）
        })

        const structureValidation = yield* validationService.validateRecipeStructure(invalidTimeRecipe)

        expect(Either.isLeft(structureValidation)).toBe(true)

        yield* assertPropertyHolds(
          structureValidation,
          (result) => Either.isLeft(result),
          'Invalid crafting time detection'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )
  })

  // ===================================
  // Ingredients Validation Tests
  // ===================================

  describe('Ingredients Validation', () => {
    it.effect('should validate correct ingredient configurations', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const ingredientsMap = new Map([
          ['wood' as any, yield* QuantityVo.create(4)],
          ['stone' as any, yield* QuantityVo.create(2)],
          ['iron' as any, yield* QuantityVo.create(1)],
        ])

        const validationResult = yield* validationService.validateIngredients(ingredientsMap)

        expect(Either.isRight(validationResult)).toBe(true)

        yield* assertPropertyHolds(validationResult, (result) => Either.isRight(result), 'Valid ingredients validation')
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should reject empty ingredient maps', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const emptyIngredients = new Map()

        const validationResult = yield* validationService.validateIngredients(emptyIngredients)

        expect(Either.isLeft(validationResult)).toBe(true)

        yield* assertPropertyHolds(validationResult, (result) => Either.isLeft(result), 'Empty ingredients rejection')
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should reject ingredients with invalid quantities', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const invalidQuantityIngredients = new Map([
          ['wood' as any, QuantityVo.unsafe(0)], // 無効な数量
          ['stone' as any, yield* QuantityVo.create(2)],
        ])

        const validationResult = yield* validationService.validateIngredients(invalidQuantityIngredients)

        expect(Either.isLeft(validationResult)).toBe(true)

        yield* assertPropertyHolds(
          validationResult,
          (result) => Either.isLeft(result),
          'Invalid quantity ingredients rejection'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should validate ingredient stack limits', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const maxStackIngredients = new Map([
          ['wood' as any, yield* QuantityVo.create(64)], // 最大スタック
          ['stone' as any, yield* QuantityVo.create(32)],
        ])

        const validationResult = yield* validationService.validateIngredients(maxStackIngredients)

        expect(Either.isRight(validationResult)).toBe(true)

        // 過剰な数量のテスト
        const overStackIngredients = new Map([
          ['wood' as any, QuantityVo.unsafe(100)], // スタック制限超過
        ])

        const overStackValidation = yield* validationService.validateIngredients(overStackIngredients)

        expect(Either.isLeft(overStackValidation)).toBe(true)

        yield* assertPropertyHolds(
          { validResult: validationResult, invalidResult: overStackValidation },
          ({ validResult, invalidResult }) => Either.isRight(validResult) && Either.isLeft(invalidResult),
          'Ingredient stack limit validation'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )
  })

  // ===================================
  // Pattern Validation Tests
  // ===================================

  describe('Pattern Validation', () => {
    it.effect('should validate correct 3x3 patterns', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const validPattern = [
          ['planks', 'planks', 'planks'],
          [null, 'stick', null],
          [null, 'stick', null],
        ]

        const validationResult = yield* validationService.validatePattern(validPattern)

        expect(Either.isRight(validationResult)).toBe(true)

        yield* assertPropertyHolds(validationResult, (result) => Either.isRight(result), 'Valid 3x3 pattern validation')
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should reject invalid pattern dimensions', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const invalidPattern = [
          ['item1', 'item2'],
          ['item3', 'item4'],
        ] as any

        const validationResult = yield* validationService.validatePattern(invalidPattern)

        expect(Either.isLeft(validationResult)).toBe(true)

        yield* assertPropertyHolds(
          validationResult,
          (result) => Either.isLeft(result),
          'Invalid pattern dimensions rejection'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should validate empty patterns', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const emptyPattern = [
          [null, null, null],
          [null, null, null],
          [null, null, null],
        ]

        const validationResult = yield* validationService.validatePattern(emptyPattern)

        expect(Either.isLeft(validationResult)).toBe(true) // 空のパターンは無効

        yield* assertPropertyHolds(validationResult, (result) => Either.isLeft(result), 'Empty pattern rejection')
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should validate patterns with mixed content', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const mixedPattern = [
          ['wood', null, 'stone'],
          [null, 'iron', null],
          ['diamond', null, 'gold'],
        ]

        const validationResult = yield* validationService.validatePattern(mixedPattern)

        expect(Either.isRight(validationResult)).toBe(true)

        yield* assertPropertyHolds(
          validationResult,
          (result) => Either.isRight(result),
          'Mixed content pattern validation'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )
  })

  // ===================================
  // Business Rule Validation Tests
  // ===================================

  describe('Business Rule Validation', () => {
    it.effect('should enforce recipe complexity rules', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        // 高難易度レシピのルール検証
        const complexRecipe = createTestRecipeAggregate({
          difficulty: yield* DifficultyVo.create(9),
          craftingTime: yield* TimeVo.create(10000),
          successRate: yield* SuccessRateVo.create(0.6),
          requiredIngredients: new Map([
            ['rare_material' as any, yield* QuantityVo.create(16)],
            ['epic_component' as any, yield* QuantityVo.create(4)],
          ]),
        })

        yield* assertBusinessRule(
          complexRecipe,
          (recipe) => {
            const difficulty = DifficultyVo.toNumber(recipe.difficulty)
            const time = TimeVo.toMilliseconds(recipe.craftingTime)
            const successRate = SuccessRateVo.toNumber(recipe.successRate)

            // 高難易度レシピは時間が長く、成功率が低いべき
            return difficulty >= 8 && time >= 5000 && successRate <= 0.8
              ? Either.right(recipe)
              : Either.left('High difficulty recipes must have longer times and lower success rates')
          },
          'Recipe complexity rules'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should enforce ingredient-difficulty correlation', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const recipe = createTestRecipeAggregate({
          difficulty: yield* DifficultyVo.create(8),
          requiredIngredients: new Map([
            ['common_wood' as any, yield* QuantityVo.create(2)], // 低難易度なのに高難易度設定
          ]),
        })

        yield* assertBusinessRule(
          recipe,
          (r) => {
            const difficulty = DifficultyVo.toNumber(r.difficulty)
            const totalIngredients = Array.from(r.requiredIngredients.values()).reduce(
              (sum, qty) => sum + QuantityVo.toNumber(qty),
              0
            )

            // 材料数と難易度の相関性チェック
            return (difficulty <= 3 && totalIngredients <= 8) ||
              (difficulty <= 6 && totalIngredients <= 16) ||
              (difficulty <= 10 && totalIngredients <= 32)
              ? Either.right(r)
              : Either.left('Recipe difficulty should correlate with ingredient complexity')
          },
          'Ingredient-difficulty correlation'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should validate result-ingredient balance', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const recipe = createTestRecipeAggregate({
          result: {
            itemId: 'simple_tool' as any,
            quantity: yield* QuantityVo.create(1),
          },
          requiredIngredients: new Map([['expensive_material' as any, yield* QuantityVo.create(32)]]),
        })

        yield* assertBusinessRule(
          recipe,
          (r) => {
            const resultQuantity = QuantityVo.toNumber(r.result.quantity)
            const totalInputs = Array.from(r.requiredIngredients.values()).reduce(
              (sum, qty) => sum + QuantityVo.toNumber(qty),
              0
            )

            // 投入材料に対して結果が妥当な範囲であることを確認
            return resultQuantity >= 1 && totalInputs / resultQuantity <= 64
              ? Either.right(r)
              : Either.left('Recipe output should be proportional to input materials')
          },
          'Result-ingredient balance'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )
  })

  // ===================================
  // Property-based Tests
  // ===================================

  describe('Property-based Tests', () => {
    it.effect('should maintain validation consistency', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        // 同じレシピを複数回検証しても同じ結果が得られることを確認
        for (let i = 0; i < 20; i++) {
          const recipe = createTestRecipeAggregate({
            id: yield* RecipeIdVo.create(`consistency-test-${i}`),
          })

          const validation1 = yield* validationService.validateRecipe(recipe)
          const validation2 = yield* validationService.validateRecipe(recipe)

          yield* assertPropertyHolds(
            { validation1, validation2 },
            ({ validation1, validation2 }) => Either.isRight(validation1) === Either.isRight(validation2),
            `Validation consistency for recipe ${i}`
          )
        }
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )

    it.effect('should validate different recipe types consistently', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const shapedRecipe = createTestRecipeAggregate({
          type: 'shaped',
          pattern: [
            ['wood', 'wood', null],
            ['wood', 'wood', null],
            [null, null, null],
          ],
        })

        const shapelessRecipe = createTestRecipeAggregate({
          type: 'shapeless',
          ingredients: [{ itemId: 'wheat' as any, quantity: yield* QuantityVo.create(3) }],
        })

        const shapedValidation = yield* validationService.validateRecipe(shapedRecipe)
        const shapelessValidation = yield* validationService.validateRecipe(shapelessRecipe)

        yield* assertPropertyHolds(
          { shapedValidation, shapelessValidation },
          ({ shapedValidation, shapelessValidation }) =>
            Either.isRight(shapedValidation) && Either.isRight(shapelessValidation),
          'Different recipe types validation'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )
  })

  // ===================================
  // Concurrency Tests
  // ===================================

  describe('Concurrency Tests', () => {
    it.effect('should handle concurrent validations safely', () =>
      Effect.gen(function* () {
        const concurrentValidations = Array.from({ length: 50 }, (_, i) =>
          Effect.gen(function* () {
            const validationService = yield* RecipeValidationService.RecipeValidationService

            const recipe = createTestRecipeAggregate({
              id: yield* RecipeIdVo.create(`concurrent-test-${i}`),
              difficulty: yield* DifficultyVo.create(((i % 10) + 1) as any),
            })

            return yield* validationService.validateRecipe(recipe)
          }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
        )

        // 並行実行不変条件: 全ての検証が成功する
        yield* assertConcurrencyInvariant(
          concurrentValidations,
          (results) => results.every((result) => Either.isRight(result)),
          'Concurrent validation safety'
        )
      })
    )

    it.effect('should maintain service state during concurrent access', () =>
      Effect.gen(function* () {
        const concurrentAccesses = Array.from({ length: 30 }, (_, i) =>
          Effect.gen(function* () {
            const validationService = yield* RecipeValidationService.RecipeValidationService

            const ingredients = new Map([[`material-${i}` as any, yield* QuantityVo.create((i % 32) + 1)]])

            const ingredientValidation = yield* validationService.validateIngredients(ingredients)
            const structureValidation = yield* validationService.validateRecipeStructure(createTestRecipeAggregate())

            return {
              ingredientResult: ingredientValidation,
              structureResult: structureValidation,
            }
          }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
        )

        const results = yield* Effect.all(concurrentAccesses, { concurrency: 'unbounded' })

        yield* assertPropertyHolds(
          results,
          (resultArray) =>
            resultArray.every(
              (result) => Either.isRight(result.ingredientResult) && Either.isRight(result.structureResult)
            ),
          'Service state consistency during concurrent access'
        )
      })
    )
  })

  // ===================================
  // Error Handling Tests
  // ===================================

  describe('Error Handling', () => {
    it.effect('should provide meaningful error messages', () =>
      Effect.gen(function* () {
        const validationService = yield* RecipeValidationService.RecipeValidationService

        const invalidRecipe = createTestRecipeAggregate({
          requiredIngredients: new Map(),
          difficulty: DifficultyVo.unsafe(15),
          successRate: SuccessRateVo.unsafe(1.5),
        })

        const validationResult = yield* validationService.validateRecipe(invalidRecipe)

        expect(Either.isLeft(validationResult)).toBe(true)
        if (Either.isLeft(validationResult)) {
          const error = validationResult.left
          expect(error.message).toBeTruthy()
          expect(typeof error.message).toBe('string')
        }

        yield* assertPropertyHolds(
          validationResult,
          (result) => Either.isLeft(result),
          'Meaningful error message provision'
        )
      }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
    )
  })

  // ===================================
  // Performance Tests
  // ===================================

  describe('Performance Tests', () => {
    it.effect('should handle high-volume validations efficiently', () =>
      Effect.gen(function* () {
        const operationCount = 500
        const maxExecutionTime = 300 // 300ms for 500 validations

        const bulkValidations = Array.from({ length: operationCount }, (_, i) =>
          Effect.gen(function* () {
            const validationService = yield* RecipeValidationService.RecipeValidationService

            const recipe = createTestRecipeAggregate({
              id: yield* RecipeIdVo.create(`perf-test-${i}`),
            })

            return yield* validationService.validateRecipe(recipe)
          }).pipe(Effect.provide(RecipeValidationService.RecipeValidationServiceLive))
        )

        const startTime = Date.now()
        const results = yield* Effect.all(bulkValidations, { concurrency: 'unbounded' })
        const endTime = Date.now()
        const executionTime = endTime - startTime

        expect(executionTime).toBeLessThan(maxExecutionTime)
        expect(results.length).toBe(operationCount)

        yield* assertPropertyHolds(
          { results, executionTime, maxTime: maxExecutionTime },
          ({ results, executionTime, maxTime }) =>
            results.length === operationCount &&
            executionTime < maxTime &&
            results.every((result) => Either.isRight(result)),
          'High-volume validation performance'
        )
      })
    )
  })
})
