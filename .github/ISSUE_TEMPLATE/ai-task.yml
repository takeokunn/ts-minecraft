name: AI Agent Task
description: AI Coding Agent自動実行用 構造化タスク
title: "[TASK-ID] タスク名"
labels: ["ai-agent", "task", "execution-plan", "auto-executable"]
assignees: ["@me"]
body:
  - type: markdown
    attributes:
      value: |
        ## 🤖 AI Coding Agent自動実行タスク

        このテンプレートはClaude Agentが `claude "Issue #N を実装して"` で自動実行できる構造化タスクを作成します。

        **実行コマンド**: `claude "Issue #[番号] を実装して"`

  - type: input
    id: task-id
    attributes:
      label: Task ID
      description: ROADMAPのタスクID (P0-001形式)
      placeholder: P0-001
    validations:
      required: true

  - type: dropdown
    id: complexity
    attributes:
      label: 実装複雑度
      description: AI Agentが判断する技術的複雑度
      options:
        - "1 - Very Simple (設定変更レベル)"
        - "2 - Simple (単純な関数実装)"
        - "3 - Easy (基本的な機能実装)"
        - "4 - Medium-Easy (複数ファイル実装)"
        - "5 - Medium (標準的な機能実装)"
        - "6 - Medium-Hard (複雑なロジック)"
        - "7 - Hard (アーキテクチャ変更)"
        - "8 - Very Hard (大規模リファクタリング)"
        - "9 - Expert (新技術・パターン導入)"
        - "10 - Extreme (フルスタック実装)"
    validations:
      required: true

  - type: dropdown
    id: ai-guidance
    attributes:
      label: AI実装ガイダンスレベル
      description: AI Agentが必要とする指示の詳細度
      options:
        - "Minimal - 基本要件のみ"
        - "Standard - 通常レベルの指示"
        - "Detailed - 詳細な実装指示"
        - "Expert - 高度な技術指示と制約"
    validations:
      required: true

  - type: textarea
    id: ai-context
    attributes:
      label: AI実装コンテキスト
      description: AI Agentが参照すべき既存実装・パターン・制約
      placeholder: |
        **参照実装**:
        - src/shared/services/ の既存パターン
        - docs/reference/api/ の仕様書

        **技術制約**:
        - Effect-TS 3.17+ 必須使用
        - Schema.Struct による型定義
        - 60FPS維持、メモリ2GB以下

        **禁止事項**:
        - class使用禁止
        - var/let/any/async/await禁止
    validations:
      required: true

  - type: textarea
    id: execution-phases
    attributes:
      label: 実行ステップ（AI Agent自動実行用）
      description: Claude Agentが順次実行するステップ。各ステップは自動実行可能な具体的アクションで記述
      placeholder: |
        ## Step 1: 事前調査・分析（10分）
        ```bash
        # 1.1 プロジェクト構造確認
        ls -la src/domain/      # ドメインロジック確認
        ls -la src/systems/     # ECSシステム確認
        ls -la src/shared/      # 共有パターン確認

        # 1.2 依存関係確認
        grep -E "(effect|@effect)" package.json    # Effect-TSバージョン確認
        grep -E "three" package.json               # Three.jsバージョン確認

        # 1.3 既存実装パターン検索
        grep -r "Context.GenericTag" src/          # Service定義パターン
        grep -r "Schema.Struct" src/               # Data構造パターン
        grep -r "Layer.effect" src/                # Layer実装パターン
        ```

        ## Step 2: ディレクトリ・ファイル構造作成（5分）
        ```typescript
        // 2.1 機能ディレクトリ作成
        mkdir -p src/domain/[feature]/
        mkdir -p src/domain/[feature]/types/
        mkdir -p src/domain/[feature]/services/
        mkdir -p src/domain/[feature]/errors/

        // 2.2 ファイル作成計画
        touch src/domain/[feature]/index.ts               # エクスポート集約
        touch src/domain/[feature]/types/[Feature].ts     # 型定義
        touch src/domain/[feature]/services/[Feature]Service.ts  # Service実装
        touch src/domain/[feature]/errors/[Feature]Error.ts      # エラー定義
        touch src/domain/[feature]/[Feature].test.ts      # テストファイル
        ```

        ## Step 3: 型定義・データ構造実装（15分）
        ```typescript
        // 3.1 src/domain/[feature]/types/[Feature].ts
        import { Schema } from "@effect/schema"

        // Data構造定義（必須）
        export const [Feature]Data = Schema.Struct({
          id: Schema.String,
          name: Schema.String,
          position: Schema.Struct({
            x: Schema.Number,
            y: Schema.Number,
            z: Schema.Number
          }),
          // 追加フィールド...
        })
        export type [Feature]Data = Schema.Schema.Type<typeof [Feature]Data>

        // 3.2 エラー型定義
        // src/domain/[feature]/errors/[Feature]Error.ts
        export const [Feature]Error = Schema.TaggedError("[Feature]Error")({
          type: Schema.Literal("NOT_FOUND", "INVALID_STATE", "PERMISSION_DENIED"),
          message: Schema.String,
          details: Schema.optional(Schema.Unknown)
        })
        ```

        ## Step 4: Service実装（20分）
        ```typescript
        // 4.1 src/domain/[feature]/services/[Feature]Service.ts
        import { Context, Effect, Layer } from "effect"
        import { [Feature]Data } from "../types/[Feature]"
        import { [Feature]Error } from "../errors/[Feature]Error"

        // 4.2 Service Interface定義
        export interface [Feature]Service {
          readonly create: (data: [Feature]Data) => Effect.Effect<[Feature]Data, [Feature]Error>
          readonly get: (id: string) => Effect.Effect<[Feature]Data, [Feature]Error>
          readonly update: (id: string, data: Partial<[Feature]Data>) => Effect.Effect<[Feature]Data, [Feature]Error>
          readonly delete: (id: string) => Effect.Effect<void, [Feature]Error>
        }

        // 4.3 Context Tag作成
        export const [Feature]Service = Context.GenericTag<[Feature]Service>(
          "@minecraft/[Feature]Service"
        )

        // 4.4 Service実装
        const make[Feature]Service = (): [Feature]Service => ({
          create: (data) => Effect.gen(function* () {
            // 実装ロジック
            yield* Effect.log(`Creating [feature]: ${data.id}`)
            // バリデーション
            const validated = yield* Schema.decode([Feature]Data)(data)
            // 保存処理など
            return validated
          }),

          get: (id) => Effect.gen(function* () {
            // 取得ロジック
            yield* Effect.log(`Getting [feature]: ${id}`)
            // エラーハンドリング例
            if (!id) {
              return yield* Effect.fail(new [Feature]Error({
                type: "NOT_FOUND",
                message: `[Feature] ${id} not found`
              }))
            }
            // 実データ返却
            return { id, /* ... */ } as [Feature]Data
          }),

          // update, delete も同様に実装
        })

        // 4.5 Layer作成
        export const [Feature]ServiceLive = Layer.effect(
          [Feature]Service,
          Effect.gen(function* () {
            // 依存Service取得（必要に応じて）
            // const config = yield* ConfigService

            return make[Feature]Service()
          })
        )
        ```

        ## Step 5: ECSシステム統合（必要に応じて）（15分）
        ```typescript
        // 5.1 src/systems/[feature]System.ts
        import { System } from "../ecs/System"
        import { [Feature]Service } from "../domain/[feature]/services/[Feature]Service"

        export const create[Feature]System = Effect.gen(function* () {
          const service = yield* [Feature]Service

          return {
            update: (entities: Entity[], delta: number) => Effect.gen(function* () {
              // ECSシステムロジック
              for (const entity of entities) {
                if (entity.has[Feature]Component()) {
                  // コンポーネント更新
                  yield* service.update(entity.id, { /* ... */ })
                }
              }
            })
          }
        })
        ```

        ## Step 6: テスト実装（20分）
        ```typescript
        // 6.1 src/domain/[feature]/[Feature].test.ts
        import { describe, it, expect } from "vitest"
        import { Effect, Exit } from "effect"
        import { [Feature]Service, [Feature]ServiceLive } from "./services/[Feature]Service"
        import { [Feature]Data } from "./types/[Feature]"

        describe("[Feature]Service", () => {
          // 6.2 基本的なテストケース
          it("should create a new [feature]", async () => {
            const program = Effect.gen(function* () {
              const service = yield* [Feature]Service
              const data: [Feature]Data = {
                id: "test-1",
                name: "Test [Feature]",
                position: { x: 0, y: 0, z: 0 }
              }

              const result = yield* service.create(data)
              return result
            })

            const runnable = Effect.provide(program, [Feature]ServiceLive)
            const exit = await Effect.runPromiseExit(runnable)

            expect(Exit.isSuccess(exit)).toBe(true)
            if (Exit.isSuccess(exit)) {
              expect(exit.value.id).toBe("test-1")
            }
          })

          // 6.3 エラーケース
          it("should handle not found error", async () => {
            const program = Effect.gen(function* () {
              const service = yield* [Feature]Service
              return yield* service.get("non-existent")
            })

            const runnable = Effect.provide(program, [Feature]ServiceLive)
            const exit = await Effect.runPromiseExit(runnable)

            expect(Exit.isFailure(exit)).toBe(true)
          })

          // 6.4 Property-Based Test（必要に応じて）
          it.prop([fc.string(), fc.number()])
            ("should handle arbitrary inputs", async (id, value) => {
              // PBTロジック
            })
        })
        ```

        ## Step 7: 統合・エクスポート（5分）
        ```typescript
        // 7.1 src/domain/[feature]/index.ts
        export * from "./types/[Feature]"
        export * from "./services/[Feature]Service"
        export * from "./errors/[Feature]Error"

        // 7.2 src/domain/index.ts に追加
        export * as [Feature] from "./[feature]"

        // 7.3 必要に応じてmain Layerに統合
        // src/layers/MainLayer.ts
        import { [Feature]ServiceLive } from "../domain/[feature]"

        export const MainLayer = Layer.mergeAll(
          ConfigServiceLive,
          LoggerServiceLive,
          [Feature]ServiceLive,  // 追加
          // 他のLayer...
        )
        ```

        ## Step 8: 品質確認・最適化（10分）
        ```bash
        # 8.1 段階的な品質チェック
        pnpm typecheck                    # TypeScriptチェック
        pnpm lint --fix                   # Lint自動修正
        pnpm test src/domain/[feature]/   # 機能単位でテスト
        pnpm test:coverage                # カバレッジ確認（80%以上）
        pnpm build                        # ビルド成功確認

        # 8.2 パフォーマンス確認（必要に応じて）
        pnpm dev                          # 開発サーバー起動
        # ブラウザDevToolsでメモリ・FPS確認

        # 8.3 最終確認
        git status                        # 変更ファイル確認
        git diff                          # 変更内容確認
        ```
    validations:
      required: true

  - type: textarea
    id: success-criteria
    attributes:
      label: Acceptance Criteria（自動検証）
      description: Claude Agentが自動実行・検証する完了条件
      placeholder: |
        ## 必須検証項目（自動実行）
        ```bash
        # これらのコマンドがすべて成功すること
        pnpm typecheck       # TypeScriptエラー: 0
        pnpm lint           # Lintエラー: 0
        pnpm test           # テスト: 全パス
        pnpm test:coverage  # カバレッジ: 80%以上
        pnpm build          # ビルド: 成功
        ```

        ## コード品質基準
        - [ ] Effect-TS `Context.GenericTag` でService定義
        - [ ] `Schema.Struct` で全データ構造定義
        - [ ] `Schema.TaggedError` でエラー型定義
        - [ ] 純関数のみ（副作用はEffect内）
        - [ ] class/var/let/any/async/await 未使用

        ## パフォーマンス基準
        - [ ] レンダリング: 60FPS維持
        - [ ] メモリ使用量: 2GB以下
        - [ ] 初期ロード: 3秒以内
    validations:
      required: true

  - type: textarea
    id: verification-commands
    attributes:
      label: 自動実行コマンドシーケンス
      description: Claude Agentが順次実行する検証コマンド（失敗時は自動修正試行）
      placeholder: |
        ```bash
        # 1. 開発環境確認
        pnpm --version && node --version

        # 2. 依存関係インストール（必要に応じて）
        pnpm install

        # 3. 実装後の品質チェック（順次実行）
        pnpm typecheck || echo "TypeScriptエラーを修正してください"
        pnpm lint || pnpm lint --fix
        pnpm test || echo "テストを修正してください"
        pnpm test:coverage || echo "カバレッジ80%以上を確保してください"
        pnpm build || echo "ビルドエラーを修正してください"

        # 4. 開発サーバー起動確認（必要に応じて）
        # pnpm dev （バックグラウンド実行）

        # 5. 最終確認
        echo "✅ すべての検証が完了しました"
        ```
    validations:
      required: true

  - type: checkboxes
    id: ai-requirements
    attributes:
      label: AI Agent実装要件確認
      description: このタスクに必要なAI Agent機能
      options:
        - label: "TypeScript/Effect-TS実装能力"
          required: true
        - label: "テスト作成・実行能力"
          required: true
        - label: "ドキュメント作成能力"
        - label: "パフォーマンス最適化知識"
        - label: "アーキテクチャ設計知識"
        - label: "デバッグ・問題解決能力"
        - label: "既存コード理解・統合能力"
          required: true

  - type: textarea
    id: error-handling
    attributes:
      label: トラブルシューティングガイド（自動修正）
      description: Claude Agentが遭遇する可能性のあるエラーと自動修正手順
      placeholder: |
        ## よくあるエラーと自動修正手順

        ### 1. TypeScriptエラー
        ```bash
        # エラー: Property 'xxx' does not exist on type
        → 解決: Schema.Struct で型定義追加
        → 実行: pnpm typecheck で再確認
        ```

        ### 2. Effect-TSパターンエラー
        ```bash
        # エラー: Cannot find namespace 'Effect'
        → 解決: import * as Effect from "effect"
        → 参照: src/shared/patterns/ の既存実装
        → Context7で最新API確認: mcp__context7__get-library-docs
        ```

        ### 3. テストカバレッジ不足
        ```bash
        # エラー: Coverage is below 80%
        → 解決: vitest でユニットテスト追加
        → パターン: describe/it/expect構造
        → 実行: pnpm test:coverage で確認
        ```

        ### 4. Lintエラー
        ```bash
        # 自動修正コマンド
        pnpm lint --fix
        # 手動修正が必要な場合はエラー内容を確認
        ```

        ### 5. ビルドエラー
        ```bash
        # エラー: Module not found
        → 解決: pnpm install [package-name]
        → 確認: package.json の dependencies
        ```

        ### 6. メモリ/パフォーマンス問題
        ```bash
        # Three.jsリソース解放忘れ
        → geometry.dispose(), material.dispose(), texture.dispose()
        # Effect-TSリソース管理
        → Effect.acquireRelease パターン使用
        ```