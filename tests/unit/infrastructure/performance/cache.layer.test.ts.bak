import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { Effect, Layer, Duration, Option, Ref, TestContext, Fiber } from 'effect'
import {
  MultiLevelCacheService,
  MultiLevelCacheServiceLive,
  CacheError,
  CacheMissError,
  CacheStrategy,
  CacheLevel,
  createWriteThroughCache,
  createWriteBehindCache,
  createRefreshAheadCache,
  cached,
  memoize,
  createQueryCache,
  createEntityCache
} from '@infrastructure/performance/cache.layer'

// Mock data for testing
interface TestEntity {
  id: string
  name: string
  value: number
  timestamp: number
}

interface TestQuery {
  sql: string
  params: any[]
}

class MockLoader {
  private loadCount = 0
  private loadDelay = 10
  private failureRate = 0
  
  constructor(delay = 10, failureRate = 0) {
    this.loadDelay = delay
    this.failureRate = failureRate
  }
  
  load = (key: string): Effect.Effect<TestEntity> =>
    Effect.gen(function* () {
      this.loadCount++
      
      if (Math.random() < this.failureRate) {
        return yield* Effect.fail(new Error(`Load failed for key: ${key}`))
      }
      
      yield* Effect.sleep(Duration.millis(this.loadDelay))
      
      return {
        id: key,
        name: `Entity-${key}`,
        value: parseInt(key) * 10,
        timestamp: Date.now()
      }
    })
  
  getLoadCount = () => this.loadCount
  
  reset = () => {
    this.loadCount = 0
  }
}

class MockWriter {
  private writeCount = 0
  private writtenData = new Map<string, TestEntity>()
  private writeDelay = 5
  private failureRate = 0
  
  constructor(delay = 5, failureRate = 0) {
    this.writeDelay = delay
    this.failureRate = failureRate
  }
  
  write = (key: string, value: TestEntity): Effect.Effect<void> =>
    Effect.gen(function* () {
      this.writeCount++
      
      if (Math.random() < this.failureRate) {
        return yield* Effect.fail(new Error(`Write failed for key: ${key}`))
      }
      
      yield* Effect.sleep(Duration.millis(this.writeDelay))
      this.writtenData.set(key, { ...value })
    })
  
  getWriteCount = () => this.writeCount
  getWrittenData = () => new Map(this.writtenData)
  
  reset = () => {
    this.writeCount = 0
    this.writtenData.clear()
  }
}

describe('CacheLayer', () => {
  let testLayer: Layer.Layer<MultiLevelCacheService>
  let mockLoader: MockLoader
  let mockWriter: MockWriter

  beforeEach(() => {
    testLayer = MultiLevelCacheServiceLive
    mockLoader = new MockLoader()
    mockWriter = new MockWriter()
    vi.useFakeTimers()
  })

  afterEach(() => {
    vi.useRealTimers()
    mockLoader.reset()
    mockWriter.reset()
  })

  describe('Basic Cache Operations', () => {
    describe('set and get operations', () => {
      it('should store and retrieve values from L1 cache', async () => {
        const result = await Effect.runPromise(
          Effect.provide(
            Effect.gen(function* () {
              const cache = yield* MultiLevelCacheService
              
              const testData = { message: 'Hello Cache', number: 42 }
              
              yield* cache.set('test-key', testData, { level: 'L1' })
              const retrieved = yield* cache.get<typeof testData>('test-key')
              
              return retrieved
            }),
            testLayer
          )
        )

        expect(result.message).toBe('Hello Cache')
        expect(result.number).toBe(42)
      })

      it('should store and retrieve values from different cache levels', async () => {
        const results = []
        
        for (const level of ['L1', 'L2', 'L3'] as CacheLevel[]) {
          const result = await Effect.runPromise(Effect.provide(
            Effect.gen(function* () {
              const cache = yield* MultiLevelCacheService
              
              const testData = { level, value: `data-for-${level}` }
              
              yield* cache.set(`test-${level}`, testData, { level })
              const retrieved = yield* cache.get<typeof testData>(`test-${level}`)
              
              return retrieved
            }), testLayer)
          )
          
          results.push(result)
        }

        expect(results[0].level).toBe('L1')
        expect(results[1].level).toBe('L2')
        expect(results[2].level).toBe('L3')
      })

      it('should promote values from lower levels to L1', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cache = yield* MultiLevelCacheService
            
            const testData = { promoted: true, value: 100 }
            
            // Store in L3
            yield* cache.set('promote-test', testData, { level: 'L3' })
            
            // Retrieve should promote to L1 and L2
            const retrieved = yield* cache.get<typeof testData>('promote-test')
            
            return retrieved
          }), testLayer)
        )

        expect(result.promoted).toBe(true)
        expect(result.value).toBe(100)
      })

      it('should handle cache misses correctly', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const cache = yield* MultiLevelCacheService
            yield* cache.get('non-existent-key')
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
        if (Effect.isFailure(result)) {
          const error = result.cause.error as CacheMissError
          expect(error._tag).toBe('CacheMissError')
          expect(error.key).toBe('non-existent-key')
        }
      })
    })

    describe('TTL (Time To Live) operations', () => {
      it('should expire entries after TTL', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cache = yield* MultiLevelCacheService
            
            const testData = { expires: true }
            
            yield* cache.set('ttl-test', testData, { 
              ttl: Duration.millis(100),
              level: 'L1' 
            })
            
            // Should be available immediately
            const immediate = yield* cache.get<typeof testData>('ttl-test')
            
            // Wait for expiration
            yield* Effect.sleep(Duration.millis(150))
            
            // Should be expired now
            const afterExpiry = yield* Effect.either(cache.get<typeof testData>('ttl-test'))
            
            return {
              immediate,
              afterExpiry: Effect.isLeft(afterExpiry)
            }
          }).pipe(
            Layer.provide(testLayer),
            Effect.provide(TestContext.TestContext)
          )
        )

        expect(result.immediate.expires).toBe(true)
        expect(result.afterExpiry).toBe(true) // Should be a miss
      })
    })

    describe('has operation', () => {
      it('should check if key exists in any cache level', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cache = yield* MultiLevelCacheService
            
            const existsBefore = yield* cache.has('exists-test')
            
            yield* cache.set('exists-test', { data: 'test' }, { level: 'L2' })
            
            const existsAfter = yield* cache.has('exists-test')
            
            return { existsBefore, existsAfter }
          }), testLayer)
        )

        expect(result.existsBefore).toBe(false)
        expect(result.existsAfter).toBe(true)
      })
    })

    describe('invalidate operations', () => {
      it('should invalidate single keys', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cache = yield* MultiLevelCacheService
            
            yield* cache.set('invalidate-test', { data: 'will be removed' })
            
            const existsBefore = yield* cache.has('invalidate-test')
            
            yield* cache.invalidate('invalidate-test')
            
            const existsAfter = yield* cache.has('invalidate-test')
            
            return { existsBefore, existsAfter }
          }), testLayer)
        )

        expect(result.existsBefore).toBe(true)
        expect(result.existsAfter).toBe(false)
      })

      it('should invalidate by pattern', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cache = yield* MultiLevelCacheService
            
            // Set multiple keys with pattern
            yield* cache.set('user:1', { id: 1 })
            yield* cache.set('user:2', { id: 2 })
            yield* cache.set('product:1', { id: 1 })
            
            const usersBefore = yield* cache.has('user:1')
            const productBefore = yield* cache.has('product:1')
            
            const invalidatedCount = yield* cache.invalidatePattern('user:.*')
            
            const usersAfter = yield* cache.has('user:1')
            const productAfter = yield* cache.has('product:1')
            
            return {
              usersBefore,
              productBefore,
              invalidatedCount,
              usersAfter,
              productAfter
            }
          }), testLayer)
        )

        expect(result.usersBefore).toBe(true)
        expect(result.productBefore).toBe(true)
        expect(result.usersAfter).toBe(false)
        expect(result.productAfter).toBe(true) // Should not be affected
      })
    })

    describe('clear operations', () => {
      it('should clear specific cache level', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cache = yield* MultiLevelCacheService
            
            yield* cache.set('l1-data', { level: 1 }, { level: 'L1' })
            yield* cache.set('l2-data', { level: 2 }, { level: 'L2' })
            
            const l1Before = yield* cache.has('l1-data')
            const l2Before = yield* cache.has('l2-data')
            
            yield* cache.clear('L1')
            
            const l1After = yield* cache.has('l1-data')
            const l2After = yield* cache.has('l2-data')
            
            return { l1Before, l2Before, l1After, l2After }
          }), testLayer)
        )

        expect(result.l1Before).toBe(true)
        expect(result.l2Before).toBe(true)
        expect(result.l1After).toBe(false)
        expect(result.l2After).toBe(true) // L2 should be unaffected
      })

      it('should clear all cache levels', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cache = yield* MultiLevelCacheService
            
            yield* cache.set('all-l1', { data: 'l1' }, { level: 'L1' })
            yield* cache.set('all-l2', { data: 'l2' }, { level: 'L2' })
            yield* cache.set('all-l3', { data: 'l3' }, { level: 'L3' })
            
            const allBefore = [
              yield* cache.has('all-l1'),
              yield* cache.has('all-l2'),
              yield* cache.has('all-l3')
            ]
            
            yield* cache.clear() // Clear all levels
            
            const allAfter = [
              yield* cache.has('all-l1'),
              yield* cache.has('all-l2'),
              yield* cache.has('all-l3')
            ]
            
            return { allBefore, allAfter }
          }), testLayer)
        )

        expect(result.allBefore.every(exists => exists)).toBe(true)
        expect(result.allAfter.every(exists => !exists)).toBe(true)
      })
    })
  })

  describe('Cache Statistics and Metrics', () => {
    it('should track cache statistics', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          // Generate some cache activity
          yield* cache.set('stats-1', { value: 1 })
          yield* cache.set('stats-2', { value: 2 })
          
          // Mix of hits and misses
          yield* cache.get('stats-1') // Hit
          yield* Effect.either(cache.get('non-existent')) // Miss
          yield* cache.get('stats-2') // Hit
          
          const stats = yield* cache.getStats()
          
          return stats
        }), testLayer)
      )

      expect(result.hits).toBeGreaterThanOrEqual(2)
      expect(result.misses).toBeGreaterThanOrEqual(1)
      expect(result.hitRate).toBeGreaterThan(0)
      expect(result.hitRate).toBeLessThanOrEqual(1)
      expect(result.currentEntries).toBeGreaterThanOrEqual(2)
    })

    it('should track statistics for specific cache levels', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          yield* cache.set('l1-stats', { data: 'l1' }, { level: 'L1' })
          yield* cache.set('l2-stats', { data: 'l2' }, { level: 'L2' })
          
          yield* cache.get('l1-stats')
          yield* cache.get('l2-stats') // This will promote to L1
          
          const l1Stats = yield* cache.getStats('L1')
          const l2Stats = yield* cache.getStats('L2')
          
          return { l1Stats, l2Stats }
        }), testLayer)
      )

      expect(result.l1Stats.currentEntries).toBeGreaterThanOrEqual(1)
      expect(result.l2Stats.currentEntries).toBeGreaterThanOrEqual(0)
    })
  })

  describe('Cache Warm-up', () => {
    it('should warm up cache with preloaded data', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          const keysToWarmUp = ['warm-1', 'warm-2', 'warm-3']
          
          const statsBefore = yield* cache.getStats()
          
          yield* cache.warmUp(keysToWarmUp, mockLoader.load)
          
          const statsAfter = yield* cache.getStats()
          
          // Verify data was loaded
          const warmedData = []
          for (const key of keysToWarmUp) {
            warmedData.push(yield* cache.get<TestEntity>(key))
          }
          
          return {
            entriesBefore: statsBefore.currentEntries,
            entriesAfter: statsAfter.currentEntries,
            loadCount: mockLoader.getLoadCount(),
            warmedData
          }
        }), testLayer)
      )

      expect(result.entriesAfter).toBeGreaterThan(result.entriesBefore)
      expect(result.loadCount).toBe(3)
      expect(result.warmedData).toHaveLength(3)
      expect(result.warmedData[0].name).toBe('Entity-warm-1')
    })

    it('should handle warm-up failures gracefully', async () => {
      const failingLoader = new MockLoader(10, 0.5) // 50% failure rate
      
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          const keysToWarmUp = ['fail-1', 'fail-2', 'fail-3', 'fail-4']
          
          // This should continue even if some loads fail
          yield* cache.warmUp(keysToWarmUp, failingLoader.load).pipe(
            Effect.catchAll(() => Effect.unit) // Ignore failures
          )
          
          const stats = yield* cache.getStats()
          
          return {
            entries: stats.currentEntries,
            loadAttempts: failingLoader.getLoadCount()
          }
        }), testLayer)
      )

      expect(result.loadAttempts).toBe(4) // All should be attempted
      expect(result.entries).toBeGreaterThanOrEqual(0) // Some might succeed
    })
  })

  describe('Cache Eviction', () => {
    it('should start and manage eviction process', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          // Set some data with short TTL
          yield* cache.set('evict-1', { data: 'short-lived' }, { 
            ttl: Duration.millis(50) 
          })
          
          const evictionFiber = yield* cache.startEviction(Duration.millis(30))
          
          // Let eviction run
          yield* Effect.sleep(Duration.millis(100))
          
          // Stop eviction
          yield* Fiber.interrupt(evictionFiber)
          
          const stats = yield* cache.getStats()
          
          return {
            evictions: stats.evictions,
            fiberCreated: evictionFiber !== null
          }
        }).pipe(
          Layer.provide(testLayer),
          Effect.provide(TestContext.TestContext)
        )
      )

      expect(result.fiberCreated).toBe(true)
      expect(result.evictions).toBeGreaterThanOrEqual(0)
    })
  })

  describe('Advanced Cache Patterns', () => {
    describe('Write-Through Cache', () => {
      it('should write to both cache and storage', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const writeThrough = yield* createWriteThroughCache(
              mockLoader.load,
              mockWriter.write
            )
            
            const testEntity: TestEntity = {
              id: 'wt-1',
              name: 'WriteThrough Test',
              value: 123,
              timestamp: Date.now()
            }
            
            yield* writeThrough.set('wt-1', testEntity)
            
            const retrieved = yield* writeThrough.get('wt-1')
            
            return {
              retrieved,
              writeCount: mockWriter.getWriteCount(),
              writtenData: mockWriter.getWrittenData()
            }
          }), testLayer)
        )

        expect(result.retrieved.name).toBe('WriteThrough Test')
        expect(result.writeCount).toBe(1)
        expect(result.writtenData.has('wt-1')).toBe(true)
      })

      it('should load from storage on cache miss', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const writeThrough = yield* createWriteThroughCache(
              mockLoader.load,
              mockWriter.write
            )
            
            // This should trigger a load from storage
            const loaded = yield* writeThrough.get('wt-load-test')
            
            return {
              loaded,
              loadCount: mockLoader.getLoadCount()
            }
          }), testLayer)
        )

        expect(result.loaded.name).toBe('Entity-wt-load-test')
        expect(result.loadCount).toBe(1)
      })
    })

    describe('Write-Behind Cache', () => {
      it('should write to cache immediately and storage in background', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const writeBehind = yield* createWriteBehindCache(
              mockLoader.load,
              mockWriter.write,
              Duration.millis(50) // Short flush interval for testing
            )
            
            const testEntity: TestEntity = {
              id: 'wb-1',
              name: 'WriteBehind Test',
              value: 456,
              timestamp: Date.now()
            }
            
            // Write should be immediate to cache
            const startTime = performance.now()
            yield* writeBehind.set('wb-1', testEntity)
            const writeTime = performance.now() - startTime
            
            // Should be available immediately from cache
            const immediate = yield* writeBehind.get('wb-1')
            
            // Wait for background flush
            yield* Effect.sleep(Duration.millis(100))
            
            const stats = yield* writeBehind.getStats()
            
            return {
              immediate,
              writeTime,
              writeCount: mockWriter.getWriteCount(),
              pendingWrites: stats.pendingWrites
            }
          }).pipe(
            Layer.provide(testLayer),
            Effect.provide(TestContext.TestContext)
          )
        )

        expect(result.immediate.name).toBe('WriteBehind Test')
        expect(result.writeTime).toBeLessThan(50) // Should be fast (no sync write)
        expect(result.writeCount).toBeGreaterThanOrEqual(0) // May or may not have flushed
      })

      it('should flush pending writes manually', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const writeBehind = yield* createWriteBehindCache(
              mockLoader.load,
              mockWriter.write,
              Duration.seconds(10) // Long flush interval
            )
            
            const testEntity: TestEntity = {
              id: 'wb-flush',
              name: 'Manual Flush Test',
              value: 789,
              timestamp: Date.now()
            }
            
            yield* writeBehind.set('wb-flush', testEntity)
            
            const beforeFlush = mockWriter.getWriteCount()
            
            yield* writeBehind.flush()
            
            const afterFlush = mockWriter.getWriteCount()
            
            return {
              beforeFlush,
              afterFlush,
              writtenData: mockWriter.getWrittenData()
            }
          }), testLayer)
        )

        expect(result.afterFlush).toBeGreaterThan(result.beforeFlush)
        expect(result.writtenData.has('wb-flush')).toBe(true)
      })
    })

    describe('Refresh-Ahead Cache', () => {
      it('should refresh data in background before expiry', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const refreshAhead = yield* createRefreshAheadCache(
              mockLoader.load,
              0.5, // Refresh at 50% of TTL
              Duration.millis(100) // Short TTL for testing
            )
            
            // Initial load
            const initial = yield* refreshAhead.get('ra-1')
            const initialLoadCount = mockLoader.getLoadCount()
            
            // Wait for 60ms (60% of TTL) - should trigger background refresh
            yield* Effect.sleep(Duration.millis(60))
            
            // Access again - should get cached version but trigger refresh
            const refreshed = yield* refreshAhead.get('ra-1')
            
            // Wait a bit more for background refresh to complete
            yield* Effect.sleep(Duration.millis(50))
            
            const finalLoadCount = mockLoader.getLoadCount()
            
            return {
              initial,
              refreshed,
              initialLoadCount,
              finalLoadCount
            }
          }).pipe(
            Layer.provide(testLayer),
            Effect.provide(TestContext.TestContext)
          )
        )

        expect(result.initial.name).toBe('Entity-ra-1')
        expect(result.refreshed.name).toBe('Entity-ra-1')
        expect(result.initialLoadCount).toBe(1)
        expect(result.finalLoadCount).toBeGreaterThanOrEqual(1) // May have refreshed in background
      })

      it('should preload keys', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const refreshAhead = yield* createRefreshAheadCache(
              mockLoader.load,
              0.8,
              Duration.minutes(5)
            )
            
            const keysToPreload = ['preload-1', 'preload-2', 'preload-3']
            
            yield* refreshAhead.preload(keysToPreload)
            
            const loadCount = mockLoader.getLoadCount()
            
            // Verify data is available without additional loads
            const preloadedData = []
            for (const key of keysToPreload) {
              preloadedData.push(yield* refreshAhead.get(key))
            }
            
            const finalLoadCount = mockLoader.getLoadCount()
            
            return {
              loadCount,
              finalLoadCount,
              preloadedData
            }
          }), testLayer)
        )

        expect(result.loadCount).toBe(3) // Initial preload
        expect(result.finalLoadCount).toBe(3) // No additional loads
        expect(result.preloadedData).toHaveLength(3)
      })
    })
  })

  describe('Cache Decorators and Utilities', () => {
    describe('cached decorator', () => {
      it('should cache function results', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            let callCount = 0
            
            const expensiveOperation = (input: number) =>
              Effect.gen(function* () {
                callCount++
                yield* Effect.sleep(Duration.millis(10))
                return input * 2
              })
            
            const cachedOperation = cached('expensive-op', Duration.seconds(1))(
              expensiveOperation(42)
            )
            
            // First call should execute
            const result1 = yield* cachedOperation
            const calls1 = callCount
            
            // Second call should use cache
            const result2 = yield* cachedOperation
            const calls2 = callCount
            
            return {
              result1,
              result2,
              calls1,
              calls2
            }
          }).pipe(
            Layer.provide(testLayer),
            Effect.provide(TestContext.TestContext)
          )
        )

        expect(result.result1).toBe(84)
        expect(result.result2).toBe(84)
        expect(result.calls1).toBe(1)
        expect(result.calls2).toBe(1) // Should not increase
      })
    })

    describe('memoize utility', () => {
      it('should memoize function calls based on arguments', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            let callCount = 0
            
            const fibonacci = memoize(
              (n: number) =>
                Effect.gen(function* () {
                  callCount++
                  if (n <= 1) return n
                  const a = yield* fibonacci(n - 1)
                  const b = yield* fibonacci(n - 2)
                  return a + b
                }),
              (args) => args[0].toString(),
              Duration.minutes(1)
            )
            
            const result1 = yield* fibonacci(10)
            const calls1 = callCount
            
            const result2 = yield* fibonacci(10) // Should use cache
            const calls2 = callCount
            
            const result3 = yield* fibonacci(5) // Some calls cached, some new
            const calls3 = callCount
            
            return {
              result1,
              result2,
              result3,
              calls1,
              calls2,
              calls3
            }
          }), testLayer)
        )

        expect(result.result1).toBe(55) // 10th Fibonacci number
        expect(result.result2).toBe(55)
        expect(result.result3).toBe(5)
        expect(result.calls2).toBe(result.calls1) // No new calls for same input
        expect(result.calls3).toBeLessThan(result.calls1 + 6) // Some calls cached
      })
    })
  })

  describe('Specialized Caches', () => {
    describe('Query Cache', () => {
      it('should cache query results with short TTL', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const queryCache = yield* createQueryCache({
              maxSize: 1000,
              ttl: 5
            })
            
            const testQuery = {
              sql: 'SELECT * FROM users WHERE id = ?',
              params: [123]
            }
            
            yield* queryCache.set('user-query-123', testQuery)
            
            const retrieved = yield* queryCache.get<typeof testQuery>('user-query-123')
            
            return retrieved
          }), testLayer)
        )

        expect(result.sql).toBe('SELECT * FROM users WHERE id = ?')
        expect(result.params).toEqual([123])
      })

      it('should invalidate all queries', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const queryCache = yield* createQueryCache()
            
            yield* queryCache.set('query-1', { sql: 'SELECT 1' })
            yield* queryCache.set('query-2', { sql: 'SELECT 2' })
            
            const beforeInvalidate = [
              yield* queryCache.get('query-1').pipe(Effect.either),
              yield* queryCache.get('query-2').pipe(Effect.either)
            ]
            
            yield* queryCache.invalidateAll()
            
            const afterInvalidate = [
              yield* queryCache.get('query-1').pipe(Effect.either),
              yield* queryCache.get('query-2').pipe(Effect.either)
            ]
            
            return {
              beforeInvalidate: beforeInvalidate.map(Effect.isRight),
              afterInvalidate: afterInvalidate.map(Effect.isRight)
            }
          }), testLayer)
        )

        expect(result.beforeInvalidate.every(exists => exists)).toBe(true)
        expect(result.afterInvalidate.every(exists => !exists)).toBe(true)
      })
    })

    describe('Entity Cache', () => {
      it('should cache entities with automatic key prefixing', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const entityCache = yield* createEntityCache()
            
            const testEntity: TestEntity = {
              id: 'ent-123',
              name: 'Test Entity',
              value: 999,
              timestamp: Date.now()
            }
            
            yield* entityCache.set('ent-123', testEntity)
            
            const retrieved = yield* entityCache.get<TestEntity>('ent-123')
            
            return retrieved
          }), testLayer)
        )

        expect(result.id).toBe('ent-123')
        expect(result.name).toBe('Test Entity')
        expect(result.value).toBe(999)
      })

      it('should warm up entities using loader', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const entityCache = yield* createEntityCache()
            
            const entityIds = ['warm-1', 'warm-2', 'warm-3']
            
            yield* entityCache.warmUp(entityIds, mockLoader.load)
            
            const loadCount = mockLoader.getLoadCount()
            
            // Verify entities are cached
            const entities = []
            for (const id of entityIds) {
              entities.push(yield* entityCache.get<TestEntity>(id))
            }
            
            const finalLoadCount = mockLoader.getLoadCount()
            
            return {
              loadCount,
              finalLoadCount,
              entities
            }
          }), testLayer)
        )

        expect(result.loadCount).toBe(3)
        expect(result.finalLoadCount).toBe(3) // No additional loads
        expect(result.entities).toHaveLength(3)
        expect(result.entities[0].name).toBe('Entity-warm-1')
      })
    })
  })

  describe('Performance and Optimization', () => {
    it('should handle high-throughput scenarios', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          const operations = []
          const startTime = performance.now()
          
          // Generate many concurrent cache operations
          for (let i = 0; i < 100; i++) {
            operations.push(
              Effect.gen(function* () {
                const key = `perf-${i}`
                const data = { id: i, value: i * 10 }
                
                yield* cache.set(key, data)
                return yield* cache.get<typeof data>(key)
              })
            )
          }
          
          const results = yield* Effect.all(operations, { concurrency: 10 })
          const endTime = performance.now()
          
          const stats = yield* cache.getStats()
          
          return {
            operationCount: results.length,
            totalTime: endTime - startTime,
            averageTime: (endTime - startTime) / results.length,
            hitRate: stats.hitRate,
            entries: stats.currentEntries
          }
        }), testLayer)
      )

      expect(result.operationCount).toBe(100)
      expect(result.totalTime).toBeGreaterThan(0)
      expect(result.averageTime).toBeLessThan(10) // Should be fast
      expect(result.entries).toBeGreaterThanOrEqual(100)
    })

    it('should optimize memory usage across cache levels', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          // Fill different cache levels
          for (let i = 0; i < 50; i++) {
            yield* cache.set(`l1-${i}`, { data: `l1-data-${i}` }, { level: 'L1' })
          }
          
          for (let i = 0; i < 100; i++) {
            yield* cache.set(`l2-${i}`, { data: `l2-data-${i}` }, { level: 'L2' })
          }
          
          for (let i = 0; i < 200; i++) {
            yield* cache.set(`l3-${i}`, { data: `l3-data-${i}` }, { level: 'L3' })
          }
          
          const l1Stats = yield* cache.getStats('L1')
          const l2Stats = yield* cache.getStats('L2')
          const l3Stats = yield* cache.getStats('L3')
          const overallStats = yield* cache.getStats()
          
          return {
            l1Entries: l1Stats.currentEntries,
            l2Entries: l2Stats.currentEntries,
            l3Entries: l3Stats.currentEntries,
            totalEntries: overallStats.currentEntries,
            overallSize: overallStats.currentSize
          }
        }), testLayer)
      )

      expect(result.l1Entries).toBeGreaterThanOrEqual(50)
      expect(result.l2Entries).toBeGreaterThanOrEqual(100)
      expect(result.l3Entries).toBeGreaterThanOrEqual(200)
      expect(result.totalEntries).toBeGreaterThanOrEqual(350)
      expect(result.overallSize).toBeGreaterThan(0)
    })
  })

  describe('Error Handling and Edge Cases', () => {
    it('should handle cache corruption gracefully', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          // Set valid data
          yield* cache.set('corrupt-test', { valid: true, data: 'good' })
          
          // Simulate corruption by trying to get with wrong type expectation
          // This is more of a TypeScript issue, but we can test graceful handling
          const validData = yield* cache.get<{ valid: boolean; data: string }>('corrupt-test')
          
          return validData
        }), testLayer)
      )

      expect(result.valid).toBe(true)
      expect(result.data).toBe('good')
    })

    it('should handle concurrent invalidation and access', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          yield* cache.set('concurrent-test', { data: 'original' })
          
          const operations = [
            cache.get<{ data: string }>('concurrent-test'),
            cache.invalidate('concurrent-test'),
            cache.get<{ data: string }>('concurrent-test').pipe(Effect.either),
            cache.set('concurrent-test', { data: 'new' }),
            cache.get<{ data: string }>('concurrent-test')
          ]
          
          const results = yield* Effect.all(operations, { concurrency: 'unbounded' })
          
          return results
        }), testLayer)
      )

      // First get should succeed
      expect(result[0].data).toBe('original')
      
      // One of the middle operations might fail (expected)
      const middleResult = result[2]
      
      // Last get should succeed with new data
      expect(result[4].data).toBe('new')
    })

    it('should handle memory pressure scenarios', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          // Try to fill cache with large objects
          const largeData = new Array(10000).fill(0).map((_, i) => ({ id: i, data: `large-data-${i}` }))
          
          let successCount = 0
          let errorCount = 0
          
          for (let i = 0; i < 1000; i++) {
            const result = yield* cache.set(`large-${i}`, largeData).pipe(Effect.either)
            
            if (Effect.isRight(result)) {
              successCount++
            } else {
              errorCount++
            }
            
            // Early exit if too many errors
            if (errorCount > 100) break
          }
          
          const stats = yield* cache.getStats()
          
          return {
            successCount,
            errorCount,
            currentEntries: stats.currentEntries,
            currentSize: stats.currentSize
          }
        }), testLayer)
      )

      expect(result.successCount).toBeGreaterThanOrEqual(0)
      expect(result.currentEntries).toBeGreaterThanOrEqual(0)
      expect(result.currentSize).toBeGreaterThanOrEqual(0)
    })

    it('should handle rapid cache flushes', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          // Set up some data
          for (let i = 0; i < 10; i++) {
            yield* cache.set(`flush-${i}`, { data: i })
          }
          
          const beforeFlush = yield* cache.getStats()
          
          // Perform rapid flushes
          const flushOperations = Array.from({ length: 5 }, () => cache.clear())
          
          yield* Effect.all(flushOperations, { concurrency: 'unbounded' })
          
          const afterFlush = yield* cache.getStats()
          
          return {
            entriesBefore: beforeFlush.currentEntries,
            entriesAfter: afterFlush.currentEntries
          }
        }), testLayer)
      )

      expect(result.entriesBefore).toBeGreaterThanOrEqual(10)
      expect(result.entriesAfter).toBe(0)
    })
  })

  describe('Cache Persistence and Recovery', () => {
    it('should handle service restarts gracefully', async () => {
      // This test simulates what would happen during a service restart
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const cache = yield* MultiLevelCacheService
          
          // Set up data
          yield* cache.set('persistent-1', { data: 'should survive' })
          yield* cache.set('persistent-2', { data: 'will be lost' })
          
          const beforeStats = yield* cache.getStats()
          
          // Simulate restart by clearing and reinitializing
          yield* cache.clear()
          
          // This simulates data that might be restored from persistent storage
          yield* cache.set('persistent-1', { data: 'restored' })
          
          const afterStats = yield* cache.getStats()
          const restoredData = yield* cache.get<{ data: string }>('persistent-1')
          
          return {
            entriesBefore: beforeStats.currentEntries,
            entriesAfter: afterStats.currentEntries,
            restoredData
          }
        }), testLayer)
      )

      expect(result.entriesBefore).toBeGreaterThanOrEqual(2)
      expect(result.entriesAfter).toBe(1)
      expect(result.restoredData.data).toBe('restored')
    })
  })
})