import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { Effect, Layer, Duration, Option, TestContext } from 'effect'
import {
  ObjectPoolService,
  ObjectPoolServiceLive,
  ObjectPoolError,
  PoolExhaustedError,
  PoolableObject,
  ObjectPoolConfig,
  createPooledVector3,
  createPooledMatrix4,
  createPooledAABB,
  createVector3Pool,
  createMatrix4Pool,
  createAABBPool,
  withPooledEffect,
  withPooledOrFallback,
  withTemporaryPool,
  createPoolCluster,
  vector3PoolConfig,
  matrix4PoolConfig,
  aabbPoolConfig
} from '@infrastructure/performance/object-pool.layer'

// Test implementations of poolable objects
class TestObject implements PoolableObject {
  public value: number = 0
  public name: string = ''
  
  constructor(initialValue: number = 0, initialName: string = '') {
    this.value = initialValue
    this.name = initialName
  }
  
  reset(): void {
    this.value = 0
    this.name = ''
  }
  
  setValue(value: number): this {
    this.value = value
    return this
  }
  
  setName(name: string): this {
    this.name = name
    return this
  }
}

class ExpensiveObject implements PoolableObject {
  public data: number[]
  public timestamp: number
  
  constructor() {
    this.data = new Array(1000).fill(0).map((_, i) => i)
    this.timestamp = Date.now()
  }
  
  reset(): void {
    this.data.fill(0)
    this.timestamp = 0
  }
  
  compute(): number {
    return this.data.reduce((sum, val) => sum + val, 0)
  }
}

class FailingResetObject implements PoolableObject {
  public shouldFailReset: boolean = false
  
  reset(): void {
    if (this.shouldFailReset) {
      throw new Error('Reset failed')
    }
  }
  
  makeResetFail(): void {
    this.shouldFailReset = true
  }
}

describe('ObjectPoolLayer', () => {
  let testLayer: Layer.Layer<ObjectPoolService>

  beforeEach(() => {
    testLayer = ObjectPoolServiceLive
    vi.useFakeTimers()
  })

  afterEach(() => {
    vi.useRealTimers()
  })

  describe('Basic Pool Operations', () => {
    describe('createPool', () => {
      it('should create an object pool with default configuration', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => new TestObject())
            
            const stats = yield* pool.getStats
            
            return {
              available: stats.available,
              total: stats.total,
              maxSize: stats.maxSize
            }
          }), testLayer)
        )

        expect(result.available).toBe(10) // Default initial size
        expect(result.total).toBe(10)
        expect(result.maxSize).toBe(1000) // Default max size
      })

      it('should create a pool with custom configuration', async () => {
        const config: ObjectPoolConfig = {
          initialSize: 5,
          maxSize: 20,
          growthFactor: 1.5,
          shrinkThreshold: 0.4,
          enableBackpressure: true,
          backpressureThreshold: 15,
          enableMetrics: true,
          poolName: 'test-custom-pool',
          autoOptimize: true,
          maxIdleTime: 60000
        }

        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => new TestObject(), config)
            
            const stats = yield* pool.getStats
            
            return {
              available: stats.available,
              total: stats.total,
              maxSize: stats.maxSize,
              poolName: stats.poolName
            }
          }), testLayer)
        )

        expect(result.available).toBe(5)
        expect(result.total).toBe(5)
        expect(result.maxSize).toBe(20)
        expect(result.poolName).toBe('test-custom-pool')
      })

      it('should handle factory errors during initialization', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            yield* service.createPool(() => {
              throw new Error('Factory failed')
            }, { initialSize: 2, maxSize: 10 })
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
        if (Effect.isFailure(result)) {
          const error = result.cause.error as ObjectPoolError
          expect(error._tag).toBe('ObjectPoolError')
          expect(error.operation).toBe('initialization')
        }
      })
    })

    describe('acquire operations', () => {
      it('should acquire objects from the pool', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(42, 'test'), 
              { initialSize: 3, maxSize: 10 }
            )
            
            const obj1 = yield* pool.acquire
            const obj2 = yield* pool.acquire
            
            const stats = yield* pool.getStats
            
            return {
              obj1: { value: obj1.value, name: obj1.name },
              obj2: { value: obj2.value, name: obj2.name },
              inUse: stats.inUse,
              available: stats.available
            }
          }), testLayer)
        )

        expect(result.obj1.value).toBe(42)
        expect(result.obj1.name).toBe('test')
        expect(result.obj2.value).toBe(42)
        expect(result.obj2.name).toBe('test')
        expect(result.inUse).toBe(2)
        expect(result.available).toBe(1)
      })

      it('should create new objects when pool is empty', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(Math.random()), 
              { initialSize: 1, maxSize: 5, enableMetrics: true }
            )
            
            // Acquire the initial object
            const obj1 = yield* pool.acquire
            
            // Acquire a new object (should create since pool is empty)
            const obj2 = yield* pool.acquire
            
            const stats = yield* pool.getStats
            
            return {
              inUse: stats.inUse,
              total: stats.total,
              totalAcquired: stats.totalAcquired,
              hitRate: stats.hitRate
            }
          }), testLayer)
        )

        expect(result.inUse).toBe(2)
        expect(result.total).toBe(2)
        expect(result.totalAcquired).toBe(2)
        expect(result.hitRate).toBeLessThan(1) // Should be less than 100% due to pool miss
      })

      it('should handle pool exhaustion', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 1, maxSize: 1 }
            )
            
            // Acquire the only available object
            yield* pool.acquire
            
            // Try to acquire another object (should fail)
            yield* pool.acquire
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
        if (Effect.isFailure(result)) {
          const error = result.cause.error as PoolExhaustedError
          expect(error._tag).toBe('PoolExhaustedError')
        }
      })

      it('should track acquisition metrics', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 2, maxSize: 10, enableMetrics: true }
            )
            
            const startTime = performance.now()
            
            const obj = yield* pool.acquire
            
            const endTime = performance.now()
            const stats = yield* pool.getStats
            
            return {
              acquisitionTime: endTime - startTime,
              avgAcquisitionTime: stats.acquisitionTime,
              totalAcquired: stats.totalAcquired,
              peakUsage: stats.peakUsage
            }
          }), testLayer)
        )

        expect(result.avgAcquisitionTime).toBeGreaterThanOrEqual(0)
        expect(result.totalAcquired).toBe(1)
        expect(result.peakUsage).toBe(1)
      })
    })

    describe('tryAcquire operations', () => {
      it('should return Some when objects are available', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(99, 'available'), 
              { initialSize: 2, maxSize: 10 }
            )
            
            const maybeObj = yield* pool.tryAcquire
            
            return {
              hasSome: Option.isSome(maybeObj),
              value: Option.isSome(maybeObj) ? maybeObj.value.value : null,
              name: Option.isSome(maybeObj) ? maybeObj.value.name : null
            }
          }), testLayer)
        )

        expect(result.hasSome).toBe(true)
        expect(result.value).toBe(99)
        expect(result.name).toBe('available')
      })

      it('should return None when no objects are available', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 1, maxSize: 1 }
            )
            
            // Acquire the only object
            yield* pool.acquire
            
            // Try to acquire when none available
            const maybeObj = yield* pool.tryAcquire
            
            return Option.isNone(maybeObj)
          }), testLayer)
        )

        expect(result).toBe(true)
      })
    })

    describe('acquireWithTimeout operations', () => {
      it('should acquire object within timeout', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(123), 
              { initialSize: 1, maxSize: 10 }
            )
            
            const obj = yield* pool.acquireWithTimeout(Duration.seconds(1))
            
            return obj.value
          }), testLayer)
        )

        expect(result).toBe(123)
      })

      it('should timeout when no objects become available', async () => {
        const timeoutResult = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 0, maxSize: 0 }
            )
            
            yield* pool.acquireWithTimeout(Duration.millis(10))
          }).pipe(
            Layer.provide(testLayer),
            Effect.provide(TestContext.TestContext)
          )
        )

        expect(Effect.isFailure(timeoutResult)).toBe(true)
      })
    })

    describe('release operations', () => {
      it('should release objects back to the pool', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 2, maxSize: 10, enableMetrics: true }
            )
            
            const obj = yield* pool.acquire
            obj.setValue(42).setName('modified')
            
            const beforeRelease = yield* pool.getStats
            
            yield* pool.release(obj)
            
            const afterRelease = yield* pool.getStats
            
            // Acquire again to check if it was reset
            const resetObj = yield* pool.acquire
            
            return {
              beforeInUse: beforeRelease.inUse,
              afterInUse: afterRelease.inUse,
              afterAvailable: afterRelease.available,
              wasReset: resetObj.value === 0 && resetObj.name === '',
              totalReleased: afterRelease.totalReleased
            }
          }), testLayer)
        )

        expect(result.beforeInUse).toBe(1)
        expect(result.afterInUse).toBe(0)
        expect(result.afterAvailable).toBe(2)
        expect(result.wasReset).toBe(true)
        expect(result.totalReleased).toBe(1)
      })

      it('should handle reset failures gracefully', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => new FailingResetObject())
            
            const obj = yield* pool.acquire
            obj.makeResetFail()
            
            yield* pool.release(obj)
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
        if (Effect.isFailure(result)) {
          const error = result.cause.error as ObjectPoolError
          expect(error._tag).toBe('ObjectPoolError')
          expect(error.operation).toBe('release')
        }
      })

      it('should reject releasing foreign objects', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => new TestObject())
            
            const foreignObj = new TestObject()
            yield* pool.release(foreignObj)
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
        if (Effect.isFailure(result)) {
          const error = result.cause.error as ObjectPoolError
          expect(error._tag).toBe('ObjectPoolError')
          expect(error.operation).toBe('release')
        }
      })
    })
  })

  describe('Batch Operations', () => {
    describe('acquireBatch', () => {
      it('should acquire multiple objects', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 5, maxSize: 10 }
            )
            
            const objects = yield* pool.acquireBatch(3)
            const stats = yield* pool.getStats
            
            return {
              objectCount: objects.length,
              inUse: stats.inUse,
              available: stats.available
            }
          }), testLayer)
        )

        expect(result.objectCount).toBe(3)
        expect(result.inUse).toBe(3)
        expect(result.available).toBe(2)
      })

      it('should create new objects when needed', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 2, maxSize: 10 }
            )
            
            const objects = yield* pool.acquireBatch(5) // More than initially available
            const stats = yield* pool.getStats
            
            return {
              objectCount: objects.length,
              totalObjects: stats.total,
              inUse: stats.inUse
            }
          }), testLayer)
        )

        expect(result.objectCount).toBe(5)
        expect(result.totalObjects).toBe(5) // Should have created 3 new objects
        expect(result.inUse).toBe(5)
      })

      it('should fail when batch size exceeds pool capacity', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 2, maxSize: 5 }
            )
            
            yield* pool.acquireBatch(6) // More than max size
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
        if (Effect.isFailure(result)) {
          const error = result.cause.error as PoolExhaustedError
          expect(error._tag).toBe('PoolExhaustedError')
        }
      })
    })

    describe('releaseBatch', () => {
      it('should release multiple objects', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 2, maxSize: 10, enableMetrics: true }
            )
            
            const objects = yield* pool.acquireBatch(3)
            
            // Modify objects
            objects.forEach((obj, i) => obj.setValue(i * 10))
            
            const beforeRelease = yield* pool.getStats
            
            yield* pool.releaseBatch(objects)
            
            const afterRelease = yield* pool.getStats
            
            return {
              beforeInUse: beforeRelease.inUse,
              afterInUse: afterRelease.inUse,
              totalReleased: afterRelease.totalReleased
            }
          }), testLayer)
        )

        expect(result.beforeInUse).toBe(3)
        expect(result.afterInUse).toBe(0)
        expect(result.totalReleased).toBe(3)
      })

      it('should handle partial release failures', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => new TestObject())
            
            const objects = yield* pool.acquireBatch(2)
            const foreignObj = new TestObject()
            
            // Try to release mix of valid and invalid objects
            yield* pool.releaseBatch([...objects, foreignObj])
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
        if (Effect.isFailure(result)) {
          const error = result.cause.error as ObjectPoolError
          expect(error._tag).toBe('ObjectPoolError')
          expect(error.operation).toBe('releaseBatch')
        }
      })

      it('should continue with other objects when some reset fails', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            let resetCount = 0
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => ({
              reset() {
                resetCount++
                if (resetCount === 2) {
                  throw new Error('Second reset fails')
                }
              }
            } as PoolableObject))
            
            const objects = yield* pool.acquireBatch(3)
            
            yield* pool.releaseBatch(objects)
            
            const stats = yield* pool.getStats
            
            return {
              resetCount,
              inUse: stats.inUse,
              totalReleased: stats.totalReleased
            }
          }), testLayer)
        )

        expect(result.resetCount).toBe(3) // All should be attempted
        expect(result.inUse).toBe(0) // All should be marked as released
        expect(result.totalReleased).toBe(3)
      })
    })

    describe('releaseAll', () => {
      it('should release all in-use objects', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 2, maxSize: 10 }
            )
            
            // Acquire multiple objects
            yield* pool.acquire
            yield* pool.acquire
            yield* pool.acquire
            
            const beforeReleaseAll = yield* pool.getStats
            
            yield* pool.releaseAll
            
            const afterReleaseAll = yield* pool.getStats
            
            return {
              beforeInUse: beforeReleaseAll.inUse,
              afterInUse: afterReleaseAll.inUse,
              afterAvailable: afterReleaseAll.available
            }
          }), testLayer)
        )

        expect(result.beforeInUse).toBe(3)
        expect(result.afterInUse).toBe(0)
        expect(result.afterAvailable).toBe(5) // 2 initial + 3 released
      })
    })
  })

  describe('Pool Growth and Optimization', () => {
    describe('grow', () => {
      it('should grow pool according to growth factor', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 4, maxSize: 20, growthFactor: 2 }
            )
            
            const beforeGrow = yield* pool.getStats
            
            yield* pool.grow
            
            const afterGrow = yield* pool.getStats
            
            return {
              beforeTotal: beforeGrow.total,
              afterTotal: afterGrow.total,
              beforeAvailable: beforeGrow.available,
              afterAvailable: afterGrow.available
            }
          }), testLayer)
        )

        expect(result.afterTotal).toBeGreaterThan(result.beforeTotal)
        expect(result.afterAvailable).toBeGreaterThan(result.beforeAvailable)
      })

      it('should respect maximum size when growing', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 8, maxSize: 10, growthFactor: 2 }
            )
            
            yield* pool.grow
            
            const stats = yield* pool.getStats
            
            return stats.total
          }), testLayer)
        )

        expect(result).toBe(10) // Should be capped at maxSize
      })
    })

    describe('shrink', () => {
      it('should shrink pool to target size', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 10, maxSize: 20 }
            )
            
            const beforeShrink = yield* pool.getStats
            
            yield* pool.shrink(5)
            
            const afterShrink = yield* pool.getStats
            
            return {
              beforeTotal: beforeShrink.total,
              afterTotal: afterShrink.total,
              beforeAvailable: beforeShrink.available,
              afterAvailable: afterShrink.available
            }
          }), testLayer)
        )

        expect(result.afterTotal).toBeLessThan(result.beforeTotal)
        expect(result.afterAvailable).toBeLessThan(result.beforeAvailable)
      })

      it('should use shrink threshold when no target specified', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 10, maxSize: 20, shrinkThreshold: 0.5 }
            )
            
            yield* pool.shrink() // No target specified
            
            const stats = yield* pool.getStats
            
            return stats.total
          }), testLayer)
        )

        expect(result).toBeLessThan(10)
      })
    })

    describe('optimize', () => {
      it('should optimize pool based on utilization', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 10, maxSize: 20, shrinkThreshold: 0.8, enableMetrics: true }
            )
            
            const beforeOptimize = yield* pool.getStats
            
            yield* pool.optimize
            
            const afterOptimize = yield* pool.getStats
            
            return {
              beforeTotal: beforeOptimize.total,
              afterTotal: afterOptimize.total,
              fragmentationRatio: afterOptimize.fragmentationRatio
            }
          }), testLayer)
        )

        expect(result.fragmentationRatio).toBeGreaterThanOrEqual(0)
        // Should shrink due to low utilization
        expect(result.afterTotal).toBeLessThanOrEqual(result.beforeTotal)
      })
    })
  })

  describe('Pool Management', () => {
    describe('clear', () => {
      it('should clear all objects and reset metrics', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 5, maxSize: 10 }
            )
            
            // Acquire some objects
            yield* pool.acquire
            yield* pool.acquire
            
            const beforeClear = yield* pool.getStats
            
            yield* pool.clear
            
            const afterClear = yield* pool.getStats
            
            return {
              beforeTotal: beforeClear.total,
              beforeInUse: beforeClear.inUse,
              afterTotal: afterClear.total,
              afterInUse: afterClear.inUse,
              afterAvailable: afterClear.available
            }
          }), testLayer)
        )

        expect(result.beforeTotal).toBe(5)
        expect(result.beforeInUse).toBe(2)
        expect(result.afterTotal).toBe(0)
        expect(result.afterInUse).toBe(0)
        expect(result.afterAvailable).toBe(0)
      })
    })

    describe('warmUp', () => {
      it('should pre-allocate objects', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 3, maxSize: 15 }
            )
            
            const beforeWarmUp = yield* pool.getStats
            
            yield* pool.warmUp(5)
            
            const afterWarmUp = yield* pool.getStats
            
            return {
              beforeTotal: beforeWarmUp.total,
              afterTotal: afterWarmUp.total
            }
          }), testLayer)
        )

        expect(result.beforeTotal).toBe(3)
        expect(result.afterTotal).toBe(8) // 3 + 5
      })

      it('should respect max size during warm-up', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 8, maxSize: 10 }
            )
            
            yield* pool.warmUp(5) // Should only add 2 more
            
            const stats = yield* pool.getStats
            
            return stats.total
          }), testLayer)
        )

        expect(result).toBe(10) // Capped at maxSize
      })

      it('should handle factory errors during warm-up', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            let createdCount = 0
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => {
              createdCount++
              if (createdCount > 3) {
                throw new Error('Factory failed during warm-up')
              }
              return new TestObject()
            }, { initialSize: 2, maxSize: 10 })
            
            yield* pool.warmUp(5)
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
      })
    })

    describe('resize', () => {
      it('should resize pool to new max size', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 5, maxSize: 10 }
            )
            
            const beforeResize = yield* pool.getStats
            
            yield* pool.resize(20)
            
            const afterResize = yield* pool.getStats
            
            return {
              beforeMaxSize: beforeResize.maxSize,
              afterMaxSize: afterResize.maxSize
            }
          }), testLayer)
        )

        expect(result.beforeMaxSize).toBe(10)
        expect(result.afterMaxSize).toBe(20)
      })

      it('should shrink when new size is smaller', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 8, maxSize: 15 }
            )
            
            const beforeResize = yield* pool.getStats
            
            yield* pool.resize(5)
            
            const afterResize = yield* pool.getStats
            
            return {
              beforeTotal: beforeResize.total,
              afterTotal: afterResize.total,
              afterMaxSize: afterResize.maxSize
            }
          }), testLayer)
        )

        expect(result.beforeTotal).toBe(8)
        expect(result.afterTotal).toBeLessThanOrEqual(5)
        expect(result.afterMaxSize).toBe(5)
      })

      it('should reject resizing below initial size', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(), 
              { initialSize: 10, maxSize: 20 }
            )
            
            yield* pool.resize(5) // Below initial size
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
      })
    })
  })

  describe('Backpressure and Health', () => {
    it('should handle backpressure when enabled', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          const pool = yield* service.createPool(
            () => new TestObject(), 
            { 
              initialSize: 2, 
              maxSize: 10,
              enableBackpressure: true,
              backpressureThreshold: 3,
              enableMetrics: true 
            }
          )
          
          // Acquire objects to approach backpressure threshold
          yield* pool.acquire
          yield* pool.acquire
          yield* pool.acquire
          
          const stats = yield* pool.getStats
          
          return {
            inUse: stats.inUse,
            backpressureEvents: stats.backpressureEvents
          }
        }), testLayer)
      )

      expect(result.inUse).toBe(3)
      expect(result.backpressureEvents).toBeGreaterThanOrEqual(0)
    })
  })

  describe('Shared Pool Management', () => {
    it('should create and reuse shared pools', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          
          const pool1 = yield* service.createSharedPool(
            () => new TestObject(1), 
            'shared-test-pool',
            { initialSize: 3, maxSize: 10 }
          )
          
          const pool2 = yield* service.createSharedPool(
            () => new TestObject(2), 
            'shared-test-pool',
            { initialSize: 5, maxSize: 15 } // Different config should be ignored
          )
          
          const obj1 = yield* pool1.acquire
          const obj2 = yield* pool2.acquire
          
          return {
            isSamePool: pool1 === pool2,
            obj1Value: obj1.value,
            obj2Value: obj2.value
          }
        }), testLayer)
      )

      expect(result.isSamePool).toBe(true)
      expect(result.obj1Value).toBe(1) // Should use first factory
      expect(result.obj2Value).toBe(1) // Should be same pool
    })

    it('should get metrics for shared pools', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          
          yield* service.createSharedPool(
            () => new TestObject(), 
            'metrics-pool-1',
            { initialSize: 3, maxSize: 10 }
          )
          
          yield* service.createSharedPool(
            () => new ExpensiveObject(), 
            'metrics-pool-2',
            { initialSize: 2, maxSize: 8 }
          )
          
          const specificMetrics = yield* service.getPoolMetrics('metrics-pool-1')
          const allMetrics = yield* service.getPoolMetrics()
          
          return {
            specificCount: specificMetrics.length,
            specificName: specificMetrics[0]?.poolName,
            allCount: allMetrics.length
          }
        }), testLayer)
      )

      expect(result.specificCount).toBe(1)
      expect(result.specificName).toBe('metrics-pool-1')
      expect(result.allCount).toBeGreaterThanOrEqual(2)
    })

    it('should start global optimization', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          
          yield* service.createSharedPool(
            () => new TestObject(), 
            'optimize-test-pool',
            { initialSize: 5, maxSize: 15 }
          )
          
          const fiber = yield* service.startGlobalOptimization(Duration.seconds(1))
          
          // Let it run briefly
          yield* Effect.sleep(Duration.millis(50))
          
          return fiber !== null
        }).pipe(
          Layer.provide(testLayer),
          Effect.provide(TestContext.TestContext)
        )
      )

      expect(result).toBe(true)
    })

    it('should clear all pools', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          
          yield* service.createSharedPool(
            () => new TestObject(), 
            'clear-test-pool-1'
          )
          
          yield* service.createSharedPool(
            () => new TestObject(), 
            'clear-test-pool-2'
          )
          
          const beforeClear = yield* service.getPoolMetrics()
          
          yield* service.clearAllPools
          
          const afterClear = yield* service.getPoolMetrics()
          
          return {
            beforeCount: beforeClear.length,
            afterCount: afterClear.length
          }
        }), testLayer)
      )

      expect(result.beforeCount).toBeGreaterThanOrEqual(2)
      expect(result.afterCount).toBe(0)
    })
  })

  describe('Specialized Pooled Objects', () => {
    describe('PooledVector3', () => {
      it('should create and operate on vector3 objects', () => {
        const vector = createPooledVector3()
        
        vector.set(1, 2, 3)
        expect(vector.x).toBe(1)
        expect(vector.y).toBe(2)
        expect(vector.z).toBe(3)
        
        const length = vector.length()
        expect(length).toBeCloseTo(Math.sqrt(14))
        
        vector.normalize()
        const normalizedLength = vector.length()
        expect(normalizedLength).toBeCloseTo(1)
        
        vector.reset()
        expect(vector.x).toBe(0)
        expect(vector.y).toBe(0)
        expect(vector.z).toBe(0)
      })

      it('should perform vector operations correctly', () => {
        const v1 = createPooledVector3().set(1, 2, 3)
        const v2 = createPooledVector3().set(4, 5, 6)
        
        v1.add(v2)
        expect(v1.x).toBe(5)
        expect(v1.y).toBe(7)
        expect(v1.z).toBe(9)
        
        v1.sub({ x: 1, y: 1, z: 1 })
        expect(v1.x).toBe(4)
        expect(v1.y).toBe(6)
        expect(v1.z).toBe(8)
        
        v1.scale(0.5)
        expect(v1.x).toBe(2)
        expect(v1.y).toBe(3)
        expect(v1.z).toBe(4)
        
        const dot = v1.dot({ x: 1, y: 0, z: 0 })
        expect(dot).toBe(2)
      })
    })

    describe('PooledMatrix4', () => {
      it('should create and operate on matrix4 objects', () => {
        const matrix = createPooledMatrix4()
        
        // Should start as identity
        expect(matrix.elements[0]).toBe(1)
        expect(matrix.elements[5]).toBe(1)
        expect(matrix.elements[10]).toBe(1)
        expect(matrix.elements[15]).toBe(1)
        
        const det = matrix.determinant()
        expect(det).toBe(1)
        
        matrix.reset()
        expect(matrix.elements[0]).toBe(1)
        expect(matrix.elements[5]).toBe(1)
      })

      it('should perform matrix operations correctly', () => {
        const m1 = createPooledMatrix4()
        const m2 = createPooledMatrix4()
        
        // Modify m2
        m2.elements[0] = 2
        m2.elements[5] = 2
        m2.elements[10] = 2
        
        m1.multiply(m2)
        
        expect(m1.elements[0]).toBe(2)
        expect(m1.elements[5]).toBe(2)
        expect(m1.elements[10]).toBe(2)
      })
    })

    describe('PooledAABB', () => {
      it('should create and operate on AABB objects', () => {
        const aabb = createPooledAABB()
        
        aabb.set(-1, -2, -3, 1, 2, 3)
        expect(aabb.minX).toBe(-1)
        expect(aabb.minY).toBe(-2)
        expect(aabb.minZ).toBe(-3)
        expect(aabb.maxX).toBe(1)
        expect(aabb.maxY).toBe(2)
        expect(aabb.maxZ).toBe(3)
        
        const center = aabb.center()
        expect(center.x).toBe(0)
        expect(center.y).toBe(0)
        expect(center.z).toBe(0)
        
        const size = aabb.size()
        expect(size.x).toBe(2)
        expect(size.y).toBe(4)
        expect(size.z).toBe(6)
        
        const volume = aabb.volume()
        expect(volume).toBe(48)
        
        aabb.reset()
        expect(aabb.minX).toBe(0)
        expect(aabb.maxX).toBe(0)
      })

      it('should test intersections and containment', () => {
        const aabb1 = createPooledAABB().set(0, 0, 0, 2, 2, 2)
        const aabb2 = createPooledAABB().set(1, 1, 1, 3, 3, 3)
        const aabb3 = createPooledAABB().set(5, 5, 5, 7, 7, 7)
        
        expect(aabb1.intersects(aabb2)).toBe(true)
        expect(aabb1.intersects(aabb3)).toBe(false)
        
        expect(aabb1.contains({ x: 1, y: 1, z: 1 })).toBe(true)
        expect(aabb1.contains({ x: 3, y: 3, z: 3 })).toBe(false)
        
        aabb1.expand(1)
        expect(aabb1.minX).toBe(-1)
        expect(aabb1.maxX).toBe(3)
      })
    })
  })

  describe('Specialized Pool Creation', () => {
    it('should create Vector3 pool with correct configuration', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const pool = yield* createVector3Pool({
            ...vector3PoolConfig,
            initialSize: 5,
            maxSize: 20
          })
          
          const vector = yield* pool.acquire
          vector.set(1, 2, 3)
          
          const stats = yield* pool.getStats
          
          return {
            vectorLength: vector.length(),
            poolName: stats.poolName,
            totalObjects: stats.total
          }
        }), testLayer)
      )

      expect(result.vectorLength).toBeCloseTo(Math.sqrt(14))
      expect(result.poolName).toBe('vector3')
      expect(result.totalObjects).toBe(5)
    })

    it('should create Matrix4 pool with correct configuration', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const pool = yield* createMatrix4Pool({
            ...matrix4PoolConfig,
            initialSize: 3,
            maxSize: 15
          })
          
          const matrix = yield* pool.acquire
          const stats = yield* pool.getStats
          
          return {
            isDeterminantOne: Math.abs(matrix.determinant() - 1) < 0.0001,
            poolName: stats.poolName,
            totalObjects: stats.total
          }
        }), testLayer)
      )

      expect(result.isDeterminantOne).toBe(true)
      expect(result.poolName).toBe('matrix4')
      expect(result.totalObjects).toBe(3)
    })

    it('should create AABB pool with correct configuration', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const pool = yield* createAABBPool({
            ...aabbPoolConfig,
            initialSize: 4,
            maxSize: 25
          })
          
          const aabb = yield* pool.acquire
          aabb.set(-1, -1, -1, 1, 1, 1)
          
          const stats = yield* pool.getStats
          
          return {
            volume: aabb.volume(),
            poolName: stats.poolName,
            totalObjects: stats.total
          }
        }), testLayer)
      )

      expect(result.volume).toBe(8)
      expect(result.poolName).toBe('aabb')
      expect(result.totalObjects).toBe(4)
    })
  })

  describe('Utility Functions', () => {
    describe('withPooledEffect', () => {
      it('should automatically acquire and release objects', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(42),
              { initialSize: 2, maxSize: 10 }
            )
            
            const processedValue = yield* withPooledEffect(pool, (obj) =>
              Effect.succeed(obj.value * 2)
            )
            
            const stats = yield* pool.getStats
            
            return {
              processedValue,
              inUse: stats.inUse
            }
          }), testLayer)
        )

        expect(result.processedValue).toBe(84)
        expect(result.inUse).toBe(0) // Should be released
      })

      it('should release object even when effect fails', async () => {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => new TestObject())
            
            yield* withPooledEffect(pool, () =>
              Effect.fail(new Error('Processing failed'))
            )
          }), testLayer)
        )

        expect(Effect.isFailure(result)).toBe(true)
        
        // Verify object was released by creating new pool and checking
        const stats = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(() => new TestObject())
            return yield* pool.getStats
          }), testLayer)
        )
        
        expect(stats.inUse).toBe(0)
      })
    })

    describe('withPooledOrFallback', () => {
      it('should use pooled object when available', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(100),
              { initialSize: 2, maxSize: 10 }
            )
            
            const value = yield* withPooledOrFallback(
              pool,
              () => new TestObject(200),
              (obj) => Effect.succeed(obj.value)
            )
            
            return value
          }), testLayer)
        )

        expect(result).toBe(100) // From pool
      })

      it('should use factory when pool is empty', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(100),
              { initialSize: 1, maxSize: 1 }
            )
            
            // Exhaust the pool
            yield* pool.acquire
            
            const value = yield* withPooledOrFallback(
              pool,
              () => new TestObject(200),
              (obj) => Effect.succeed(obj.value)
            )
            
            return value
          }), testLayer)
        )

        expect(result).toBe(200) // From factory
      })
    })

    describe('withTemporaryPool', () => {
      it('should create, use, and clean up temporary pool', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const processedValues = yield* withTemporaryPool(
              () => new TestObject(),
              { initialSize: 3, maxSize: 10 },
              (pool) => Effect.gen(function* () {
                const obj1 = yield* pool.acquire
                const obj2 = yield* pool.acquire
                
                obj1.setValue(10)
                obj2.setValue(20)
                
                return [obj1.value, obj2.value]
              })
            )
            
            return processedValues
          }), testLayer)
        )

        expect(result).toEqual([10, 20])
      })
    })

    describe('createPoolCluster', () => {
      it('should create multiple pools and manage them as a cluster', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cluster = yield* createPoolCluster(
              () => new TestObject(),
              3, // 3 pools
              { initialSize: 2, maxSize: 8, poolName: 'cluster' }
            )
            
            // Acquire from any available pool
            const obj1 = yield* cluster.acquireFromAny()
            const obj2 = yield* cluster.acquireFromAny()
            
            obj1.setValue(1)
            obj2.setValue(2)
            
            yield* cluster.releaseToAny(obj1)
            yield* cluster.releaseToAny(obj2)
            
            const clusterStats = yield* cluster.getClusterStats()
            
            return {
              poolCount: cluster.pools.length,
              totalObjects: clusterStats.total,
              totalReleased: clusterStats.totalReleased
            }
          }), testLayer)
        )

        expect(result.poolCount).toBe(3)
        expect(result.totalObjects).toBe(6) // 3 pools * 2 initial each
        expect(result.totalReleased).toBeGreaterThanOrEqual(2)
      })

      it('should balance load across pools', async () => {
        const result = await Effect.runPromise(Effect.provide(
          Effect.gen(function* () {
            const cluster = yield* createPoolCluster(
              () => new TestObject(),
              2, // 2 pools
              { initialSize: 1, maxSize: 5, poolName: 'balance-test' }
            )
            
            // Acquire multiple objects to test balancing
            const objects = []
            for (let i = 0; i < 4; i++) {
              const obj = yield* cluster.acquireFromAny()
              obj.setValue(i)
              objects.push(obj)
            }
            
            // Release all objects
            for (const obj of objects) {
              yield* cluster.releaseToAny(obj)
            }
            
            const clusterStats = yield* cluster.getClusterStats()
            
            return {
              inUse: clusterStats.inUse,
              available: clusterStats.available
            }
          }), testLayer)
        )

        expect(result.inUse).toBe(0)
        expect(result.available).toBeGreaterThanOrEqual(2) // At least initial objects
      })
    })
  })

  describe('Performance and Metrics', () => {
    it('should track acquisition and release performance', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          const pool = yield* service.createPool(
            () => new ExpensiveObject(),
            { initialSize: 2, maxSize: 10, enableMetrics: true }
          )
          
          const startTime = performance.now()
          
          const obj = yield* pool.acquire
          const midTime = performance.now()
          
          // Do some work
          const computation = obj.compute()
          
          yield* pool.release(obj)
          const endTime = performance.now()
          
          const stats = yield* pool.getStats
          
          return {
            computation,
            totalTime: endTime - startTime,
            acquisitionTime: stats.acquisitionTime,
            releaseTime: stats.releaseTime,
            totalAcquired: stats.totalAcquired,
            totalReleased: stats.totalReleased
          }
        }), testLayer)
      )

      expect(result.computation).toBeGreaterThan(0)
      expect(result.totalTime).toBeGreaterThan(0)
      expect(result.acquisitionTime).toBeGreaterThanOrEqual(0)
      expect(result.releaseTime).toBeGreaterThanOrEqual(0)
      expect(result.totalAcquired).toBe(1)
      expect(result.totalReleased).toBe(1)
    })

    it('should calculate hit rate correctly', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          const pool = yield* service.createPool(
            () => new TestObject(),
            { initialSize: 2, maxSize: 10, enableMetrics: true }
          )
          
          // First acquire should be a hit
          const obj1 = yield* pool.acquire
          yield* pool.release(obj1)
          
          const statsAfterHit = yield* pool.getStats
          
          // Acquire all available objects then one more (miss)
          yield* pool.acquire // Hit
          yield* pool.acquire // Hit
          yield* pool.acquire // Miss (new object created)
          
          const statsAfterMiss = yield* pool.getStats
          
          return {
            hitRateAfterHit: statsAfterHit.hitRate,
            hitRateAfterMiss: statsAfterMiss.hitRate,
            totalAcquired: statsAfterMiss.totalAcquired
          }
        }), testLayer)
      )

      expect(result.hitRateAfterHit).toBe(1) // 100% hit rate initially
      expect(result.hitRateAfterMiss).toBeLessThan(1) // Should decrease after miss
      expect(result.totalAcquired).toBe(4)
    })
  })

  describe('Configuration Validation', () => {
    it('should validate pool configurations', () => {
      expect(vector3PoolConfig.initialSize).toBe(100)
      expect(vector3PoolConfig.maxSize).toBe(10000)
      expect(vector3PoolConfig.enableBackpressure).toBe(true)
      
      expect(matrix4PoolConfig.initialSize).toBe(20)
      expect(matrix4PoolConfig.maxSize).toBe(1000)
      
      expect(aabbPoolConfig.initialSize).toBe(50)
      expect(aabbPoolConfig.maxSize).toBe(5000)
    })
  })

  describe('Edge Cases and Error Handling', () => {
    it('should handle concurrent access safely', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          const pool = yield* service.createPool(
            () => new TestObject(),
            { initialSize: 5, maxSize: 20 }
          )
          
          // Simulate concurrent access
          const concurrentOperations = Array.from({ length: 10 }, (_, i) =>
            Effect.gen(function* () {
              const obj = yield* pool.acquire
              obj.setValue(i)
              yield* Effect.sleep(Duration.millis(Math.random() * 10))
              yield* pool.release(obj)
              return i
            })
          )
          
          const results = yield* Effect.all(concurrentOperations, { concurrency: 'unbounded' })
          const finalStats = yield* pool.getStats
          
          return {
            completedOperations: results.length,
            inUse: finalStats.inUse
          }
        }).pipe(
          Layer.provide(testLayer),
          Effect.provide(TestContext.TestContext)
        )
      )

      expect(result.completedOperations).toBe(10)
      expect(result.inUse).toBe(0) // All objects should be released
    })

    it('should handle pool exhaustion gracefully', async () => {
      const operations = []
      
      for (let i = 0; i < 5; i++) {
        const result = await Effect.runPromiseExit(
          Effect.gen(function* () {
            const service = yield* ObjectPoolService
            const pool = yield* service.createPool(
              () => new TestObject(),
              { initialSize: 1, maxSize: 2 }
            )
            
            // Try to acquire 3 objects from a pool with max size 2
            yield* pool.acquire
            yield* pool.acquire
            yield* pool.acquire // This should fail
          }), testLayer)
        )
        
        operations.push(Effect.isFailure(result))
      }
      
      // All attempts should fail consistently
      expect(operations.every(failed => failed)).toBe(true)
    })

    it('should maintain pool integrity during errors', async () => {
      const result = await Effect.runPromise(Effect.provide(
        Effect.gen(function* () {
          const service = yield* ObjectPoolService
          const pool = yield* service.createPool(
            () => new TestObject(),
            { initialSize: 3, maxSize: 10, enableMetrics: true }
          )
          
          const obj1 = yield* pool.acquire
          const obj2 = yield* pool.acquire
          
          // Try to release a foreign object (should fail)
          const foreignObj = new TestObject()
          const releaseResult = yield* Effect.either(pool.release(foreignObj))
          
          // Pool should still be in valid state
          yield* pool.release(obj1)
          yield* pool.release(obj2)
          
          const stats = yield* pool.getStats
          
          return {
            releaseFailedAsExpected: Effect.isLeft(releaseResult),
            finalInUse: stats.inUse,
            finalAvailable: stats.available
          }
        }), testLayer)
      )

      expect(result.releaseFailedAsExpected).toBe(true)
      expect(result.finalInUse).toBe(0)
      expect(result.finalAvailable).toBe(3)
    })
  })
})